# ğŸš€ RWA å€Ÿè´·å¹³å°å‰ç«¯é›†æˆè§„åˆ™æ–‡æ¡£

> æœ€åæ›´æ–°ï¼š2025-08-13  
> æœ¬æ–‡æ¡£å®šä¹‰äº†å‰ç«¯ä¸æ™ºèƒ½åˆçº¦äº¤äº’çš„æ ‡å‡†è§„åˆ™å’Œæœ€ä½³å®è·µ
> 
> **æ ¸å¿ƒåŸåˆ™**ï¼šé‡‡ç”¨æ–¹å¼1 - ç›´æ¥è°ƒç”¨å¤šä¸ªåˆçº¦ï¼Œå®ç° Gas è´¹ç”¨ä¼˜åŒ–ã€æ¶æ„æ¸…æ™°ã€çµæ´»æ€§é«˜çš„å‰ç«¯é›†æˆæ–¹æ¡ˆ

---

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ¶æ„è®¾è®¡åŸåˆ™](#æ¶æ„è®¾è®¡åŸåˆ™)
3. [æ ¸å¿ƒåˆçº¦è°ƒç”¨æŒ‡å—](#æ ¸å¿ƒåˆçº¦è°ƒç”¨æŒ‡å—)
4. [Reward ç³»ç»Ÿé›†æˆ](#reward-ç³»ç»Ÿé›†æˆ)
5. [ç”¨æˆ·æ“ä½œæµç¨‹](#ç”¨æˆ·æ“ä½œæµç¨‹)
6. [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
7. [å®‰å…¨æœ€ä½³å®è·µ](#å®‰å…¨æœ€ä½³å®è·µ)
8. [æµ‹è¯•æŒ‡å—](#æµ‹è¯•æŒ‡å—)
9. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## ğŸ¯ æ¦‚è¿°

æœ¬å¹³å°é‡‡ç”¨**æ–¹å¼1ï¼šç›´æ¥è°ƒç”¨å¤šä¸ªåˆçº¦**çš„æ¶æ„è®¾è®¡ï¼Œæ”¯æŒå¤šèµ„äº§å€Ÿè´·ï¼Œé›†æˆäº†åŸºäº Coingecko API çš„ä»·æ ¼é¢„è¨€æœºç³»ç»Ÿå’Œå®Œæ•´çš„ç§¯åˆ†å¥–åŠ±ç³»ç»Ÿã€‚å‰ç«¯éœ€è¦éµå¾ªä»¥ä¸‹è§„åˆ™æ¥ç¡®ä¿å®‰å…¨ã€é«˜æ•ˆçš„äº¤äº’ã€‚

### ğŸ† æ ¸å¿ƒç‰¹æ€§

- âœ… **Gas è´¹ç”¨ä¼˜åŒ–**ï¼šç›´æ¥è°ƒç”¨åˆçº¦ï¼Œå‡å°‘ä¸­é—´å±‚å¼€é”€
- âœ… **æ¶æ„æ¸…æ™°**ï¼šæ¯ä¸ªåˆçº¦èŒè´£æ˜ç¡®ï¼Œä¾¿äºç»´æŠ¤å’Œå‡çº§
- âœ… **çµæ´»æ€§é«˜**ï¼šç”¨æˆ·å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©è°ƒç”¨å“ªäº›åŠŸèƒ½
- âœ… **è°ƒè¯•å‹å¥½**ï¼šé—®é¢˜å®šä½æ›´å®¹æ˜“ï¼Œé”™è¯¯å¤„ç†æ›´ç²¾ç¡®
- âœ… **å¤šèµ„äº§æ”¯æŒ**ï¼šæ”¯æŒå¤šç§ ERC20 ä»£å¸ä½œä¸ºæŠµæŠ¼ç‰©å’Œå€ºåŠ¡
- âœ… **å®æ—¶ä»·æ ¼**ï¼šåŸºäº Coingecko API çš„å®æ—¶ä»·æ ¼æ›´æ–°
- âœ… **å®‰å…¨è½¬è´¦**ï¼šä½¿ç”¨ SafeERC20 ç¡®ä¿è½¬è´¦å®‰å…¨
- âœ… **èµ„äº§ç™½åå•**ï¼šåŠ¨æ€èµ„äº§ç®¡ç†ï¼Œæ”¯æŒæ²»ç†æ§åˆ¶
- âœ… **å¥åº·å› å­**ï¼šå®æ—¶ç›‘æ§ç”¨æˆ·å€Ÿè´·å¥åº·çŠ¶æ€
- âœ… **ç§¯åˆ†å¥–åŠ±ç³»ç»Ÿ**ï¼šå®Œæ•´çš„ç”¨æˆ·æ¿€åŠ±å’Œç‰¹æƒç®¡ç†
- âœ… **æœåŠ¡é…ç½®ç®¡ç†**ï¼šçµæ´»çš„æœåŠ¡ç­‰çº§å’Œä»·æ ¼é…ç½®

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡åŸåˆ™

### å¥åº·å› å­è·¯å¾„è¿ç§»ä¸åºŸå¼ƒè¯´æ˜

èƒŒæ™¯
- æ¶æ„å·²åˆ‡æ¢ä¸ºâ€œåº“ç›´è°ƒ + ä¸šåŠ¡ä¾§æ¨é€ + View ç¼“å­˜â€çš„åŒæ¶æ„æ–¹æ¡ˆã€‚å¥åº·å› å­ç”±ä¸šåŠ¡/æ¸…ç®—æ¨¡å—è®¡ç®—ï¼Œå¹¶æ¨é€åˆ° HealthView ç¼“å­˜ï¼›å‰ç«¯ä»…è¯»å–ç¼“å­˜ä¸é˜ˆå€¼è¿›è¡Œå±•ç¤ºä¸åˆ¤æ–­ã€‚

åºŸå¼ƒé¡¹ï¼ˆå‰ç«¯ä¸å¾—å†ä½¿ç”¨ï¼‰
- IHealthFactorCalculator åŠå…¶ç›¸å…³è°ƒç”¨
- æ¨¡å—é”® KEY_HF_CALC çš„è§£æä¸æ³¨å…¥

æ›¿ä»£è·¯å¾„ï¼ˆè¯·æŒ‰ä»¥ä¸‹æ–¹å¼å®ç°ï¼‰
- è¯»å–å¥åº·å› å­ï¼šHealthView.getUserHealthFactor(user) â†’ (hfBps, isValid)
- æ‰¹é‡è¯»å–ï¼šHealthView.batchGetHealthFactors(users) â†’ (hfBps[], validFlags[])
- è¯»å–é˜ˆå€¼ï¼šLiquidationRiskManager.getMinHealthFactor() â†’ minHFBps
- åˆ¤æ–­é£é™©ï¼šhfBps < minHFBps â†’ undercollateralized
- ä»…åœ¨ oraclePriced=true çš„èµ„äº§/äº§å“ä¸Šå¯ç”¨ä¸Šè¿°æµç¨‹

è¿ç§»æç¤º
- å°†æ–‡æ¡£/ä»£ç ä¸­â€œç›´æ¥è°ƒç”¨è®¡ç®—å™¨ï¼ˆå¦‚ IHealthFactorCalculatorï¼‰â€çš„ç¤ºä¾‹ï¼Œç»Ÿä¸€æ›¿æ¢ä¸ºå¯¹ HealthView ä¸ LiquidationRiskManager çš„è¯»å–ã€‚
- å¦‚æœ‰ä½¿ç”¨ `vaultView.getHealthFactor(user)` çš„ç¤ºä¾‹ï¼Œæ”¹ä¸º `healthView.getUserHealthFactor(user)`ï¼›æ‰¹é‡æ”¹ä¸º `healthView.batchGetHealthFactors(users)`ã€‚

å‚è€ƒä»£ç ï¼ˆæœåŠ¡å±‚ï¼‰
```ts
export async function fetchUserRisk(user: string) {
  const [hfBps, isValid] = await healthView.getUserHealthFactor(user);
  const minHFBps = await liquidationRiskManager.getMinHealthFactor();
  const under = hfBps < minHFBps;
  return { hfBps, minHFBps, under, isValid };
}
```

äº‹ä»¶é©±åŠ¨ï¼ˆæ¨èï¼‰
- è®¢é˜… DataPushedï¼šRISK_STATUS_UPDATE / RISK_STATUS_UPDATE_BATCHï¼Œå¢é‡æ›´æ–° UIï¼›æ— äº‹ä»¶æ—¶å†çŸ­æœŸè½®è¯¢ HealthViewã€‚

### æ–¹å¼1ï¼šç›´æ¥è°ƒç”¨å¤šä¸ªåˆçº¦ï¼ˆæ¨èï¼‰

#### ğŸ¯ è®¾è®¡ç†å¿µ

æˆ‘ä»¬é‡‡ç”¨**ç›´æ¥è°ƒç”¨å¤šä¸ªåˆçº¦**çš„æ–¹å¼ï¼Œè€Œä¸æ˜¯é€šè¿‡ç»Ÿä¸€çš„èšåˆåˆçº¦ã€‚è¿™ç§æ–¹å¼å…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **Gas è´¹ç”¨ä¼˜åŒ–**ï¼šå‡å°‘ä¸­é—´å±‚è°ƒç”¨ï¼Œé™ä½ gas æ¶ˆè€—
2. **æ¶æ„æ¸…æ™°**ï¼šæ¯ä¸ªåˆçº¦èŒè´£æ˜ç¡®ï¼Œä¾¿äºç»´æŠ¤å’Œå‡çº§
3. **çµæ´»æ€§é«˜**ï¼šç”¨æˆ·å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©è°ƒç”¨å“ªäº›åŠŸèƒ½
4. **è°ƒè¯•å‹å¥½**ï¼šé—®é¢˜å®šä½æ›´å®¹æ˜“ï¼Œé”™è¯¯å¤„ç†æ›´ç²¾ç¡®

#### ğŸ“‹ åˆçº¦è°ƒç”¨ç­–ç•¥

```typescript
// å‰ç«¯å°è£…ç»Ÿä¸€çš„API
class RwaLendingAPI {
  private contracts: {
    vaultCore: Contract;
    vaultView: Contract;
    rewardConsumption: Contract;
    priceOracle: Contract;
    assetWhitelist: Contract;
  };

  constructor(contractAddresses: ContractAddresses, signer: Signer) {
    this.contracts = {
      vaultCore: new Contract(contractAddresses.vaultCore, VAULT_CORE_ABI, signer),
      vaultView: new Contract(contractAddresses.vaultView, VAULT_VIEW_ABI, signer),
      rewardConsumption: new Contract(contractAddresses.rewardConsumption, REWARD_CONSUMPTION_ABI, signer),
      priceOracle: new Contract(contractAddresses.priceOracle, PRICE_ORACLE_ABI, signer),
      assetWhitelist: new Contract(contractAddresses.assetWhitelist, ASSET_WHITELIST_ABI, signer)
    };
  }

  // æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
  async getUserInfo(userAddress: string) {
    const [balance, privilege, consumptions, healthFactor] = await Promise.all([
      this.contracts.rewardConsumption.getUserBalance(userAddress),
      this.contracts.rewardConsumption.getUserPrivilege(userAddress),
      this.contracts.rewardConsumption.getUserConsumptions(userAddress),
      this.contracts.vaultView.getHealthFactor(userAddress)
    ]);

    return { balance, privilege, consumptions, healthFactor };
  }

  // ç§¯åˆ†æ¶ˆè´¹
  async consumePoints(serviceType: number, level: number) {
    return await this.contracts.rewardConsumption.consumePointsForService(serviceType, level);
  }
}
```

#### ğŸ”„ æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

åœ¨ `RewardConsumption` åˆçº¦ä¸­æ·»åŠ æ‰¹é‡æŸ¥è¯¢åŠŸèƒ½ï¼š

```solidity
function getUserRewardInfo(address user) external view returns (
    uint256 balance,
    UserPrivilege memory privilege,
    ConsumptionRecord[] memory consumptions
) {
    return (
        rewardToken.balanceOf(user),
        rewardCore.getUserPrivilege(user),
        rewardCore.getUserConsumptions(user)
    );
}
```

#### ğŸ“Š åˆçº¦èŒè´£åˆ†å·¥

| åˆçº¦åç§° | ä¸»è¦èŒè´£ | è°ƒç”¨é¢‘ç‡ | Gas ä¼˜åŒ–ç­–ç•¥ |
|---------|---------|---------|-------------|
| `VaultCore` | æ ¸å¿ƒä¸šåŠ¡æ“ä½œ | é«˜ | æ‰¹é‡æ“ä½œï¼Œå‡å°‘è°ƒç”¨æ¬¡æ•° |
| `VaultView` | æŸ¥è¯¢å’Œé¢„è§ˆ | é«˜ | ç¼“å­˜ç»“æœï¼Œæ‰¹é‡æŸ¥è¯¢ |
| `RewardConsumption` | ç§¯åˆ†æ¶ˆè´¹ | ä¸­ | æ‰¹é‡æ¶ˆè´¹ï¼Œå‡å°‘äº¤æ˜“æ¬¡æ•° |
| `PriceOracle` | ä»·æ ¼æŸ¥è¯¢ | é«˜ | ç¼“å­˜ä»·æ ¼ï¼Œæ‰¹é‡æ›´æ–° |
| `AssetWhitelist` | èµ„äº§éªŒè¯ | ä¸­ | æœ¬åœ°ç¼“å­˜ç™½åå• |

---

## ğŸ¦ å¤šèµ„äº§æ”¯æŒ

### èµ„äº§ç±»å‹

1. **æŠµæŠ¼èµ„äº§**ï¼šç”¨æˆ·å­˜å…¥çš„ ERC20 ä»£å¸
2. **å€ºåŠ¡èµ„äº§**ï¼šç”¨æˆ·å€Ÿå‡ºçš„ ERC20 ä»£å¸
3. **ç»“ç®—å¸**ï¼šç”¨äºä»·å€¼è®¡ç®—çš„åŸºå‡†è´§å¸ï¼ˆé€šå¸¸ä¸º USDT/USDCï¼‰

### èµ„äº§é…ç½®

```typescript
interface AssetConfig {
  address: string;           // èµ„äº§åˆçº¦åœ°å€
  coingeckoId: string;       // Coingecko èµ„äº§ ID
  decimals: number;          // èµ„äº§ç²¾åº¦
  isActive: boolean;         // æ˜¯å¦æ¿€æ´»
  maxPriceAge: number;       // æœ€å¤§ä»·æ ¼å¹´é¾„ï¼ˆç§’ï¼‰
}
```

### æ”¯æŒçš„èµ„äº§åˆ—è¡¨

å‰ç«¯åº”å®šæœŸæŸ¥è¯¢ä»¥ä¸‹æ¥å£è·å–æ”¯æŒçš„èµ„äº§ï¼š

```solidity
// è·å–æ”¯æŒçš„èµ„äº§åˆ—è¡¨
function getSupportedAssets() external view returns (address[] memory assets);

// è·å–èµ„äº§é…ç½®
function getAssetConfig(address asset) external view returns (AssetConfig memory config);
```

---

## ğŸ”§ æ ¸å¿ƒåˆçº¦è°ƒç”¨æŒ‡å—

### ğŸ“‹ åˆçº¦åœ°å€é…ç½®

```typescript
interface ContractAddresses {
  // æ ¸å¿ƒä¸šåŠ¡åˆçº¦
  vaultCore: string;           // æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
  vaultView: string;           // æŸ¥è¯¢å’Œé¢„è§ˆåŠŸèƒ½
  vaultStorage: string;        // å­˜å‚¨å’Œé…ç½®
  
  // æ¨¡å—åŒ–åˆçº¦
  collateralManager: string;   // æŠµæŠ¼ç‰©ç®¡ç†
  lendingEngine: string;       // å€Ÿè´·å¼•æ“
  healthFactorCalculator: string; // å¥åº·å› å­è®¡ç®—
  
  // å¥–åŠ±ç³»ç»Ÿåˆçº¦
  rewardConsumption: string;   // ç§¯åˆ†æ¶ˆè´¹ç®¡ç†
  rewardManager: string;       // ç§¯åˆ†ç®¡ç†
  rewardPoints: string;        // ç§¯åˆ†ä»£å¸
  
  // åŸºç¡€è®¾æ–½åˆçº¦
  priceOracle: string;         // ä»·æ ¼é¢„è¨€æœº
  assetWhitelist: string;      // èµ„äº§ç™½åå•
  feeRouter: string;           // è´¹ç”¨è·¯ç”±
  
  // æ²»ç†åˆçº¦
  accessControlManager: string; // æƒé™ç®¡ç†
  registry: string;            // æ³¨å†Œè¡¨
}
```

### ğŸ¯ æ ¸å¿ƒåˆçº¦åŠŸèƒ½æ˜ å°„

#### 1. VaultCore - æ ¸å¿ƒä¸šåŠ¡æ“ä½œ

```typescript
class VaultCoreAPI {
  constructor(contract: Contract) {
    this.contract = contract;
  }

  // åŸºç¡€æ“ä½œ
  async deposit(asset: string, amount: string) {
    return await this.contract.deposit(asset, amount);
  }

  async withdraw(asset: string, amount: string) {
    return await this.contract.withdraw(asset, amount);
  }

  async borrow(asset: string, amount: string) {
    return await this.contract.borrow(asset, amount);
  }

  async repay(asset: string, amount: string) {
    return await this.contract.repay(asset, amount);
  }

  // å¤åˆæ“ä½œ
  async depositAndBorrow(
    collateralAsset: string,
    collateralAmount: string,
    borrowAsset: string,
    borrowAmount: string
  ) {
    return await this.contract.depositAndBorrow(
      collateralAsset,
      collateralAmount,
      borrowAsset,
      borrowAmount
    );
  }

  async repayAndWithdraw(
    repayAsset: string,
    repayAmount: string,
    withdrawAsset: string,
    withdrawAmount: string
  ) {
    return await this.contract.repayAndWithdraw(
      repayAsset,
      repayAmount,
      withdrawAsset,
      withdrawAmount
    );
  }

  // æ‰¹é‡æ“ä½œ
  async batchDeposit(assets: string[], amounts: string[]) {
    return await this.contract.batchDeposit(assets, amounts);
  }

  async batchBorrow(assets: string[], amounts: string[]) {
    return await this.contract.batchBorrow(assets, amounts);
  }

  async batchRepay(assets: string[], amounts: string[]) {
    return await this.contract.batchRepay(assets, amounts);
  }

  async batchWithdraw(assets: string[], amounts: string[]) {
    return await this.contract.batchWithdraw(assets, amounts);
  }
}
```

#### 2. VaultView - æŸ¥è¯¢å’Œé¢„è§ˆ

```typescript
class VaultViewAPI {
  constructor(contract: Contract) {
    this.contract = contract;
  }

  // ç”¨æˆ·çŠ¶æ€æŸ¥è¯¢
  async getUserPosition(user: string) {
    return await this.contract.getUserPosition(user);
  }

  async getUserStats(user: string) {
    return await this.contract.getUserStats(user);
  }

  async getHealthFactor(user: string) {
    return await this.contract.getHealthFactor(user);
  }

  async getUserTotalCollateral(user: string) {
    return await this.contract.getUserTotalCollateral(user);
  }

  async getUserTotalDebt(user: string) {
    return await this.contract.getUserTotalDebt(user);
  }

  // èµ„äº§çŠ¶æ€æŸ¥è¯¢
  async getAssetPrice(asset: string) {
    return await this.contract.getAssetPrice(asset);
  }

  async getTotalCollateral(asset: string) {
    return await this.contract.getTotalCollateral(asset);
  }

  async getTotalDebt(asset: string) {
    return await this.contract.getTotalDebt(asset);
  }

  // ç³»ç»ŸçŠ¶æ€æŸ¥è¯¢
  async getVaultCap() {
    return await this.contract.getVaultCap();
  }

  async getVaultCapRemaining() {
    return await this.contract.getVaultCapRemaining();
  }

  async getMinHealthFactor() {
    return await this.contract.getMinHealthFactor();
  }

  // é¢„è§ˆåŠŸèƒ½
  async previewBorrow(user: string, asset: string, amount: string) {
    return await this.contract.previewBorrow(user, asset, amount);
  }

  async previewRepay(user: string, asset: string, amount: string) {
    return await this.contract.previewRepay(user, asset, amount);
  }

  async previewWithdraw(user: string, asset: string, amount: string) {
    return await this.contract.previewWithdraw(user, asset, amount);
  }

  async previewDeposit(user: string, asset: string, amount: string) {
    return await this.contract.previewDeposit(user, asset, amount);
  }
}
```

#### 3. RewardConsumption - ç§¯åˆ†æ¶ˆè´¹ç®¡ç†

```typescript
class RewardConsumptionAPI {
  constructor(contract: Contract) {
    this.contract = contract;
  }

  // ç§¯åˆ†æ¶ˆè´¹
  async consumePointsForService(serviceType: number, level: number) {
    return await this.contract.consumePointsForService(serviceType, level);
  }

  // æ‰¹é‡æ¶ˆè´¹
  async batchConsumePoints(
    users: string[],
    serviceTypes: number[],
    levels: number[]
  ) {
    return await this.contract.batchConsumePoints(users, serviceTypes, levels);
  }

  // ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢
  async getUserBalance(user: string) {
    return await this.contract.getUserBalance(user);
  }

  async getUserPrivilege(user: string) {
    return await this.contract.getUserPrivilege(user);
  }

  async getUserConsumptions(user: string) {
    return await this.contract.getUserConsumptions(user);
  }

  async getUserLastConsumption(user: string, serviceType: number) {
    return await this.contract.getUserLastConsumption(user, serviceType);
  }

  // æœåŠ¡é…ç½®æŸ¥è¯¢
  async getServiceConfig(serviceType: number, level: number) {
    return await this.contract.getServiceConfig(serviceType, level);
  }

  async getServiceUsage(serviceType: number) {
    return await this.contract.getServiceUsage(serviceType);
  }

  // æœåŠ¡å‡çº§
  async upgradeServiceLevel(serviceType: number, newLevel: number) {
    return await this.contract.upgradeServiceLevel(serviceType, newLevel);
  }
}
```

#### 4. PriceOracle - ä»·æ ¼é¢„è¨€æœº

```typescript
class PriceOracleAPI {
  constructor(contract: Contract) {
    this.contract = contract;
  }

  // å•ä¸ªä»·æ ¼æŸ¥è¯¢
  async getPrice(asset: string) {
    return await this.contract.getPrice(asset);
  }

  // æ‰¹é‡ä»·æ ¼æŸ¥è¯¢
  async getPrices(assets: string[]) {
    return await this.contract.getPrices(assets);
  }

  // ä»·æ ¼æœ‰æ•ˆæ€§æ£€æŸ¥
  async isPriceValid(asset: string) {
    return await this.contract.isPriceValid(asset);
  }

  // è·å–ä»·æ ¼æ—¶é—´æˆ³
  async getPriceTimestamp(asset: string) {
    return await this.contract.getPriceTimestamp(asset);
  }
}
```

#### 5. AssetWhitelist - èµ„äº§ç™½åå•

```typescript
class AssetWhitelistAPI {
  constructor(contract: Contract) {
    this.contract = contract;
  }

  // æ£€æŸ¥èµ„äº§æ˜¯å¦åœ¨ç™½åå•ä¸­
  async isAssetAllowed(asset: string) {
    return await this.contract.isAssetAllowed(asset);
  }

  // è·å–æ‰€æœ‰æ”¯æŒçš„èµ„äº§
  async getSupportedAssets() {
    return await this.contract.getSupportedAssets();
  }

  // è·å–èµ„äº§é…ç½®
  async getAssetConfig(asset: string) {
    return await this.contract.getAssetConfig(asset);
  }
}
```

### ğŸ”„ æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šå¤šæ¬¡å•ç‹¬è°ƒç”¨
const getUserInfo = async (user: string) => {
  const balance = await rewardConsumption.getUserBalance(user);
  const privilege = await rewardConsumption.getUserPrivilege(user);
  const consumptions = await rewardConsumption.getUserConsumptions(user);
  const healthFactor = await vaultView.getHealthFactor(user);
  
  return { balance, privilege, consumptions, healthFactor };
};

// ä¼˜åŒ–åï¼šå¹¶è¡Œè°ƒç”¨
const getUserInfoOptimized = async (user: string) => {
  const [balance, privilege, consumptions, healthFactor] = await Promise.all([
    rewardConsumption.getUserBalance(user),
    rewardConsumption.getUserPrivilege(user),
    rewardConsumption.getUserConsumptions(user),
    vaultView.getHealthFactor(user)
  ]);
  
  return { balance, privilege, consumptions, healthFactor };
};
```

### ğŸ“Š åˆçº¦è°ƒç”¨é¢‘ç‡ä¼˜åŒ–

| æ“ä½œç±»å‹ | è°ƒç”¨é¢‘ç‡ | ä¼˜åŒ–ç­–ç•¥ | ç¼“å­˜ç­–ç•¥ |
|---------|---------|---------|---------|
| ä»·æ ¼æŸ¥è¯¢ | é«˜é¢‘ | æ‰¹é‡æŸ¥è¯¢ | 5åˆ†é’Ÿç¼“å­˜ |
| ç”¨æˆ·çŠ¶æ€ | é«˜é¢‘ | å¹¶è¡ŒæŸ¥è¯¢ | 1åˆ†é’Ÿç¼“å­˜ |
| ç§¯åˆ†æŸ¥è¯¢ | ä¸­é¢‘ | æ‰¹é‡æŸ¥è¯¢ | 30ç§’ç¼“å­˜ |
| ä¸šåŠ¡æ“ä½œ | ä½é¢‘ | å•æ¬¡è°ƒç”¨ | å®æ—¶æ›´æ–° |
| é…ç½®æŸ¥è¯¢ | ä½é¢‘ | æœ¬åœ°ç¼“å­˜ | 1å°æ—¶ç¼“å­˜ |

---

## ğŸ”® ä»·æ ¼é¢„è¨€æœºé›†æˆ

### é¢„è¨€æœºæ¥å£

```solidity
interface IPriceOracle {
  function getPrice(address asset) external view returns (uint256 price, uint256 timestamp, uint256 decimals);
  function getPrices(address[] calldata assets) external view returns (uint256[] memory prices, uint256[] memory timestamps, uint256[] memory decimalsArray);
  function isPriceValid(address asset) external view returns (bool isValid);
}
```

### ä»·æ ¼æ›´æ–°æœºåˆ¶

- **æ›´æ–°é¢‘ç‡**ï¼šæ¯åˆ†é’Ÿä» Coingecko API è·å–ä»·æ ¼
- **ä»·æ ¼ç²¾åº¦**ï¼š8 ä½å°æ•°ï¼ˆå¦‚ 1 USDT = 100000000ï¼‰
- **æœ‰æ•ˆæ€§æ£€æŸ¥**ï¼šä»·æ ¼å¹´é¾„ä¸è¶…è¿‡ 1 å°æ—¶
- **æ‰¹é‡æ›´æ–°**ï¼šæ”¯æŒæ‰¹é‡æ›´æ–°å¤šä¸ªèµ„äº§ä»·æ ¼

### å‰ç«¯ä»·æ ¼å¤„ç†

```typescript
// è·å–èµ„äº§ä»·æ ¼
const getAssetPrice = async (assetAddress: string) => {
  try {
    const [price, timestamp, decimals] = await priceOracle.getPrice(assetAddress);
    return {
      price: price.toString(),
      timestamp: timestamp.toNumber(),
      decimals: decimals.toNumber(),
      isValid: await priceOracle.isPriceValid(assetAddress)
    };
  } catch (error) {
    console.error('Failed to get price:', error);
    return null;
  }
};

// æ‰¹é‡è·å–ä»·æ ¼
const getBatchPrices = async (assetAddresses: string[]) => {
  try {
    const [prices, timestamps, decimalsArray] = await priceOracle.getPrices(assetAddresses);
    return assetAddresses.map((asset, index) => ({
      asset,
      price: prices[index].toString(),
      timestamp: timestamps[index].toNumber(),
      decimals: decimalsArray[index].toNumber()
    }));
  } catch (error) {
    console.error('Failed to get batch prices:', error);
    return [];
  }
};
```

---

## ğŸ”§ æ ¸å¿ƒåˆçº¦æ¥å£

### 1. æŠµæŠ¼ç®¡ç† (CollateralManager)

```solidity
// å­˜å…¥æŠµæŠ¼ç‰©
function depositCollateral(address user, address asset, uint256 amount) external;

// æå–æŠµæŠ¼ç‰©
function withdrawCollateral(address user, address asset, uint256 amount) external;

// æŸ¥è¯¢ç”¨æˆ·æŠµæŠ¼ä½™é¢
function getCollateral(address user, address asset) external view returns (uint256 amount);

// æŸ¥è¯¢ç”¨æˆ·æ€»æŠµæŠ¼ä»·å€¼
function getUserTotalCollateralValue(address user) external view returns (uint256 totalValue);

// æŸ¥è¯¢ç”¨æˆ·æŒ‡å®šèµ„äº§ä»·å€¼
function getUserAssetValue(address user, address asset) external view returns (uint256 value);
```

### 2. å€Ÿè´·å¼•æ“ (LendingEngine)

```solidity
// å€Ÿæ¬¾
function borrow(address user, address asset, uint256 amount, uint256 collateralAdded, uint16 termDays) external;

// è¿˜æ¬¾
function repay(address user, address asset, uint256 amount) external;

// æŸ¥è¯¢ç”¨æˆ·å€ºåŠ¡
function getDebt(address user, address asset) external view returns (uint256 debt);

// æŸ¥è¯¢ç”¨æˆ·æ€»å€ºåŠ¡ä»·å€¼
function getUserTotalDebtValue(address user) external view returns (uint256 totalValue);

// æŸ¥è¯¢ç”¨æˆ·æŒ‡å®šèµ„äº§å€ºåŠ¡ä»·å€¼
function getUserDebtValue(address user, address asset) external view returns (uint256 value);
```

### 3. ä¸»åˆçº¦ (CollateralVault)

```solidity
// å­˜å…¥æŠµæŠ¼ç‰©
function deposit(address asset, uint256 amount) external;

// æå–æŠµæŠ¼ç‰©
function withdraw(address asset, uint256 amount) external;

// å€Ÿæ¬¾
function borrow(address asset, uint256 amount) external;

// è¿˜æ¬¾
function repay(address asset, uint256 amount) external;

// å¤åˆæ“ä½œï¼šå­˜å…¥å¹¶å€Ÿæ¬¾
function depositAndBorrow(address collateralAsset, uint256 collateralAmount, address borrowAsset, uint256 borrowAmount) external;

// å¤åˆæ“ä½œï¼šè¿˜æ¬¾å¹¶æå–
function repayAndWithdraw(address repayAsset, uint256 repayAmount, address withdrawAsset, uint256 withdrawAmount) external;
```

### 4. ä¿è¯é‡‘ç®¡ç† (GuaranteeFundManager)

```solidity
// æŸ¥è¯¢ç”¨æˆ·æŒ‡å®šèµ„äº§çš„é”å®šä¿è¯é‡‘
function getLockedGuarantee(address user, address asset) external view returns (uint256 amount);

// æŸ¥è¯¢æŒ‡å®šèµ„äº§çš„æ€»ä¿è¯é‡‘
function getTotalGuaranteeByAsset(address asset) external view returns (uint256 totalAmount);

// æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰ä¿è¯é‡‘èµ„äº§åˆ—è¡¨
function getUserGuaranteeAssets(address user) external pure returns (address[] memory assets);

// æ‰¹é‡é”å®šä¿è¯é‡‘ï¼ˆä»… VaultCore å¯è°ƒç”¨ï¼‰
function batchLockGuarantees(address user, address[] calldata assets, uint256[] calldata amounts) external;

// æ‰¹é‡é‡Šæ”¾ä¿è¯é‡‘ï¼ˆä»… VaultCore å¯è°ƒç”¨ï¼‰
function batchReleaseGuarantees(address user, address[] calldata assets, uint256[] calldata amounts) external;

// æ²¡æ”¶ç”¨æˆ·ä¿è¯é‡‘ï¼ˆä»… VaultCore å¯è°ƒç”¨ï¼‰
function forfeitGuarantee(address user, address asset, address feeReceiver) external;
```

---

## ğŸ›¡ï¸ ä¼˜é›…é™çº§ç›‘æ§é›†æˆ

### ç³»ç»Ÿæ¦‚è¿°

ä¼˜é›…é™çº§ç›‘æ§æ˜¯ RWA å€Ÿè´·å¹³å°çš„æ ¸å¿ƒå¥åº·ç®¡ç†æ¨¡å—ï¼Œç”¨äºç›‘æ§å’Œç®¡ç†ç³»ç»Ÿä¸­å„ä¸ªæ¨¡å—çš„å¥åº·çŠ¶æ€ã€‚å½“æŸä¸ªæ¨¡å—å‡ºç°é—®é¢˜æ—¶ï¼Œç³»ç»Ÿä¸ä¼šå®Œå…¨å´©æºƒï¼Œè€Œæ˜¯ä½¿ç”¨å¤‡ç”¨ç­–ç•¥ç»§ç»­è¿è¡Œã€‚

#### æ ¸å¿ƒç‰¹æ€§

- ğŸ” **å¥åº·çŠ¶æ€ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å„ä¸ªæ¨¡å—çš„å¥åº·çŠ¶æ€
- ğŸ“Š **é™çº§äº‹ä»¶è®°å½•**ï¼šè®°å½•ç³»ç»Ÿé™çº§äº‹ä»¶å’ŒåŸå› 
- ğŸ“ˆ **ç»Ÿè®¡åˆ†æ**ï¼šæä¾›é™çº§è¶‹åŠ¿å’Œç»Ÿè®¡ä¿¡æ¯
- ğŸ“š **å†å²è®°å½•**ï¼šä¿å­˜é™çº§å†å²ç”¨äºåˆ†æ
- âš ï¸ **é£é™©é¢„è­¦**ï¼šåŠæ—¶å‘ç°æ¨¡å—å¼‚å¸¸å¹¶å‘Šè­¦

### æ ¸å¿ƒåˆçº¦

```typescript
interface GracefulDegradationContracts {
  gracefulDegradationMonitor: string;  // ä¼˜é›…é™çº§ç›‘æ§åˆçº¦
  healthView: string;                  // å¥åº·è§†å›¾åˆçº¦
  systemView: string;                  // ç³»ç»Ÿè§†å›¾åˆçº¦
}
```

### 1. ä¼˜é›…é™çº§ç›‘æ§å™¨ (GracefulDegradationMonitor)

#### è·å–é™çº§ç»Ÿè®¡ä¿¡æ¯

```typescript
const getDegradationStats = async () => {
  try {
    const gracefulDegradationMonitor = new ethers.Contract(
      gracefulDegradationMonitorAddress,
      GRACEFUL_DEGRADATION_MONITOR_ABI,
      provider
    );

    const stats = await gracefulDegradationMonitor.getGracefulDegradationStats();
    
    return {
      totalDegradations: stats.totalDegradations.toString(),
      lastDegradationTime: stats.lastDegradationTime.toNumber(),
      lastDegradedModule: stats.lastDegradedModule,
      lastDegradationReason: stats.lastDegradationReason,
      fallbackValueUsed: stats.fallbackValueUsed.toString(),
      totalFallbackValue: stats.totalFallbackValue.toString(),
      averageFallbackValue: stats.averageFallbackValue.toString()
    };
  } catch (error) {
    console.error('Failed to get degradation stats:', error);
    throw error;
  }
};
```

#### æ£€æŸ¥æ¨¡å—å¥åº·çŠ¶æ€

```typescript
const checkModuleHealth = async (moduleAddress: string) => {
  try {
    const gracefulDegradationMonitor = new ethers.Contract(
      gracefulDegradationMonitorAddress,
      GRACEFUL_DEGRADATION_MONITOR_ABI,
      provider
    );

    const healthStatus = await gracefulDegradationMonitor.getModuleHealthStatus(moduleAddress);
    
    return {
      module: healthStatus.module,
      isHealthy: healthStatus.isHealthy,
      details: healthStatus.details,
      lastCheckTime: healthStatus.lastCheckTime.toNumber(),
      consecutiveFailures: healthStatus.consecutiveFailures.toNumber(),
      totalChecks: healthStatus.totalChecks.toNumber(),
      successRate: healthStatus.successRate.toNumber()
    };
  } catch (error) {
    console.error('Failed to check module health:', error);
    throw error;
  }
};
```

#### è·å–é™çº§å†å²è®°å½•

```typescript
const getDegradationHistory = async (limit: number = 10) => {
  try {
    const gracefulDegradationMonitor = new ethers.Contract(
      gracefulDegradationMonitorAddress,
      GRACEFUL_DEGRADATION_MONITOR_ABI,
      provider
    );

    const history = await gracefulDegradationMonitor.getSystemDegradationHistory(limit);
    
    return history.map(event => ({
      module: event.module,
      reason: event.reason,
      fallbackValue: event.fallbackValue.toString(),
      usedFallback: event.usedFallback,
      timestamp: event.timestamp.toNumber(),
      blockNumber: event.blockNumber.toNumber()
    }));
  } catch (error) {
    console.error('Failed to get degradation history:', error);
    throw error;
  }
};
```

#### è·å–é™çº§è¶‹åŠ¿åˆ†æ

```typescript
const getDegradationTrends = async () => {
  try {
    const gracefulDegradationMonitor = new ethers.Contract(
      gracefulDegradationMonitorAddress,
      GRACEFUL_DEGRADATION_MONITOR_ABI,
      provider
    );

    const trends = await gracefulDegradationMonitor.getSystemDegradationTrends();
    
    return {
      totalEvents: trends.totalEvents.toString(),
      recentEvents: trends.recentEvents.toString(),
      mostFrequentModule: trends.mostFrequentModule,
      averageFallbackValue: trends.averageFallbackValue.toString()
    };
  } catch (error) {
    console.error('Failed to get degradation trends:', error);
    throw error;
  }
};
```

### 2. å¥åº·è§†å›¾é›†æˆ (HealthView)

#### è·å–å¥åº·çŠ¶æ€ç›‘æ§æ•°æ®

```typescript
const getHealthViewData = async () => {
  try {
    const healthView = new ethers.Contract(
      healthViewAddress,
      HEALTH_VIEW_ABI,
      provider
    );

    const [degradationStats, moduleHealth, degradationHistory, trends] = await Promise.all([
      healthView.getGracefulDegradationStats(),
      healthView.getModuleHealthStatus(criticalModuleAddress),
      healthView.getSystemDegradationHistory(10),
      healthView.getSystemDegradationTrends()
    ]);

    return {
      degradationStats,
      moduleHealth,
      degradationHistory,
      trends
    };
  } catch (error) {
    console.error('Failed to get health view data:', error);
    throw error;
  }
};
```

### 3. ç³»ç»Ÿè§†å›¾é›†æˆ (SystemView)

#### è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€

```typescript
const getSystemHealthStatus = async () => {
  try {
    const systemView = new ethers.Contract(
      systemViewAddress,
      SYSTEM_VIEW_ABI,
      provider
    );

    const [degradationStats, moduleHealth, degradationHistory] = await Promise.all([
      systemView.getGracefulDegradationStats(),
      systemView.getModuleHealthStatus(criticalModuleAddress),
      systemView.getSystemDegradationHistory(10)
    ]);

    return {
      degradationStats,
      moduleHealth,
      degradationHistory
    };
  } catch (error) {
    console.error('Failed to get system health status:', error);
    throw error;
  }
};
```

### 4. å‰ç«¯é›†æˆæœ€ä½³å®è·µ

#### ä¼˜é›…é™çº§ç›‘æ§ Hook

```typescript
const useGracefulDegradation = () => {
  const [stats, setStats] = useState<GracefulDegradationStats | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const healthView = useContract('HealthView');

  const fetchStats = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const result = await healthView.getGracefulDegradationStats();
      setStats(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const checkModuleHealth = async (moduleAddress: string) => {
    try {
      const healthStatus = await healthView.getModuleHealthStatus(moduleAddress);
      return healthStatus;
    } catch (err) {
      throw new Error(`å¥åº·æ£€æŸ¥å¤±è´¥: ${err.message}`);
    }
  };

  const getDegradationHistory = async (limit: number = 10) => {
    try {
      return await healthView.getSystemDegradationHistory(limit);
    } catch (err) {
      throw new Error(`è·å–å†å²è®°å½•å¤±è´¥: ${err.message}`);
    }
  };

  const getDegradationTrends = async () => {
    try {
      return await healthView.getSystemDegradationTrends();
    } catch (err) {
      throw new Error(`è·å–è¶‹åŠ¿åˆ†æå¤±è´¥: ${err.message}`);
    }
  };

  useEffect(() => {
    fetchStats();
    // æ¯5åˆ†é’Ÿåˆ·æ–°ä¸€æ¬¡
    const interval = setInterval(fetchStats, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, []);

  return {
    stats,
    isLoading,
    error,
    checkModuleHealth,
    getDegradationHistory,
    getDegradationTrends,
    refreshStats: fetchStats,
  };
};
```

#### å¥åº·çŠ¶æ€ç›‘æ§ç»„ä»¶

```typescript
const SystemHealthMonitor: React.FC<SystemHealthMonitorProps> = ({
  criticalModules,
  onModuleUnhealthy,
}) => {
  const { stats, checkModuleHealth, isLoading } = useGracefulDegradation();
  const [moduleHealth, setModuleHealth] = useState<Record<string, boolean>>({});

  const checkAllModules = async () => {
    const healthStatus: Record<string, boolean> = {};
    
    for (const module of criticalModules) {
      try {
        const status = await checkModuleHealth(module);
        healthStatus[module] = status.isHealthy;
        
        if (!status.isHealthy && onModuleUnhealthy) {
          onModuleUnhealthy(module, status.details);
        }
      } catch (error) {
        healthStatus[module] = false;
        console.error(`æ£€æŸ¥æ¨¡å— ${module} å¥åº·çŠ¶æ€å¤±è´¥:`, error);
      }
    }
    
    setModuleHealth(healthStatus);
  };

  useEffect(() => {
    checkAllModules();
    // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    const interval = setInterval(checkAllModules, 30 * 1000);
    return () => clearInterval(interval);
  }, [criticalModules]);

  if (isLoading) {
    return <div>æ­£åœ¨æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€...</div>;
  }

  return (
    <div className="system-health-monitor">
      <h3>ç³»ç»Ÿå¥åº·çŠ¶æ€</h3>
      
      {stats && (
        <div className="stats-summary">
          <p>æ€»é™çº§æ¬¡æ•°: {stats.totalDegradations}</p>
          <p>æœ€åé™çº§æ—¶é—´: {new Date(stats.lastDegradationTime * 1000).toLocaleString()}</p>
          <p>å¹³å‡é™çº§å€¼: {stats.averageFallbackValue}</p>
        </div>
      )}
      
      <div className="module-health">
        <h4>å…³é”®æ¨¡å—çŠ¶æ€</h4>
        {criticalModules.map(module => (
          <div key={module} className={`module-status ${moduleHealth[module] ? 'healthy' : 'unhealthy'}`}>
            <span>{module}</span>
            <span>{moduleHealth[module] ? 'âœ… å¥åº·' : 'âŒ å¼‚å¸¸'}</span>
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 5. ä¸å…¶ä»–æ¨¡å—çš„é›†æˆ

#### ä¸ä»·æ ¼é¢„è¨€æœºé›†æˆ

```typescript
const usePriceOracleWithDegradation = () => {
  const { recordDegradationEvent } = useGracefulDegradation();
  
  const getPriceWithFallback = async (asset: string) => {
    try {
      const price = await priceOracle.getPrice(asset);
      return price;
    } catch (error) {
      // è®°å½•é™çº§äº‹ä»¶
      await recordDegradationEvent(
        priceOracle.address,
        'Price oracle timeout',
        getFallbackPrice(asset),
        true
      );
      return getFallbackPrice(asset);
    }
  };
  
  return { getPriceWithFallback };
};
```

#### ä¸æ¸…ç®—å¼•æ“é›†æˆ

```typescript
const useLiquidationEngineWithDegradation = () => {
  const { recordDegradationEvent } = useGracefulDegradation();
  
  const liquidateWithFallback = async (user: string) => {
    try {
      await liquidationEngine.liquidate(user);
      return { success: true };
    } catch (error) {
      // è®°å½•é™çº§äº‹ä»¶
      await recordDegradationEvent(
        liquidationEngine.address,
        'Liquidation failed',
        0,
        false
      );
      
      // ä½¿ç”¨å¤‡ç”¨æ¸…ç®—ç­–ç•¥
      return await emergencyLiquidation(user);
    }
  };
  
  return { liquidateWithFallback };
};
```

### 6. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

#### ä¼˜é›…é™çº§é”™è¯¯å¤„ç†

```typescript
const useGracefulDegradationWithErrorHandling = () => {
  const { checkModuleHealth } = useGracefulDegradation();
  
  const safeCheckModuleHealth = async (moduleAddress: string) => {
    try {
      return await checkModuleHealth(moduleAddress);
    } catch (error) {
      console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
      // è¿”å›é»˜è®¤å¥åº·çŠ¶æ€
      return {
        isHealthy: false,
        details: 'å¥åº·æ£€æŸ¥å¤±è´¥',
        lastCheckTime: Date.now(),
        consecutiveFailures: 1,
        totalChecks: 1,
        successRate: 0,
      };
    }
  };
  
  return { safeCheckModuleHealth };
};
```

#### ç¼“å­˜ç­–ç•¥

```typescript
const useCachedHealthData = () => {
  const [cachedData, setCachedData] = useState<Record<string, any>>({});
  const { checkModuleHealth } = useGracefulDegradation();
  
  const getCachedHealthStatus = async (moduleAddress: string) => {
    const cacheKey = `health_${moduleAddress}`;
    const cached = cachedData[cacheKey];
    
    // å¦‚æœç¼“å­˜æ—¶é—´å°äº5åˆ†é’Ÿï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®
    if (cached && Date.now() - cached.timestamp < 5 * 60 * 1000) {
      return cached.data;
    }
    
    // è·å–æ–°æ•°æ®å¹¶ç¼“å­˜
    const healthStatus = await checkModuleHealth(moduleAddress);
    setCachedData(prev => ({
      ...prev,
      [cacheKey]: {
        data: healthStatus,
        timestamp: Date.now(),
      },
    }));
    
    return healthStatus;
  };
  
  return { getCachedHealthStatus };
};
```

### 7. ç›‘æ§æŒ‡æ ‡å’Œå‘Šè­¦

#### å…³é”®ç›‘æ§æŒ‡æ ‡

```typescript
const GRACEFUL_DEGRADATION_METRICS = {
  // é™çº§é¢‘ç‡
  DEGRADATION_FREQUENCY: 'degradation_frequency',
  
  // æ¨¡å—å¥åº·ç‡
  MODULE_HEALTH_RATE: 'module_health_rate',
  
  // å¹³å‡é™çº§å€¼
  AVERAGE_FALLBACK_VALUE: 'average_fallback_value',
  
  // æœ€é¢‘ç¹é™çº§æ¨¡å—
  MOST_FREQUENT_DEGRADED_MODULE: 'most_frequent_degraded_module',
  
  // è¿ç»­å¤±è´¥æ¬¡æ•°
  CONSECUTIVE_FAILURES: 'consecutive_failures',
  
  // æˆåŠŸç‡
  SUCCESS_RATE: 'success_rate',
};
```

#### å‘Šè­¦é˜ˆå€¼é…ç½®

```typescript
const DEGRADATION_ALERT_THRESHOLDS = {
  // 24å°æ—¶å†…è¶…è¿‡10æ¬¡é™çº§
  HIGH_DEGRADATION_FREQUENCY: 10,
  
  // æ¨¡å—å¥åº·ç‡ä½äº80%
  MODULE_HEALTH_RATE: 0.8,
  
  // è¿ç»­å¤±è´¥è¶…è¿‡3æ¬¡
  CONSECUTIVE_FAILURES: 3,
  
  // å¹³å‡é™çº§å€¼è¿‡é«˜
  HIGH_AVERAGE_FALLBACK_VALUE: 1000,
};
```

#### å‘Šè­¦å¤„ç†

```typescript
const useDegradationAlerts = () => {
  const { stats } = useGracefulDegradation();
  
  useEffect(() => {
    if (stats) {
      const recentDegradations = stats.totalDegradations;
      
      if (recentDegradations > DEGRADATION_ALERT_THRESHOLDS.HIGH_DEGRADATION_FREQUENCY) {
        sendAlert({
          level: 'high',
          message: `ç³»ç»Ÿé™çº§é¢‘ç‡è¿‡é«˜: ${recentDegradations} æ¬¡`,
          category: 'degradation',
        });
      } else if (recentDegradations > 5) {
        sendAlert({
          level: 'medium',
          message: `ç³»ç»Ÿé™çº§æ¬¡æ•°å¢åŠ : ${recentDegradations} æ¬¡`,
          category: 'degradation',
        });
      }
    }
  }, [stats]);
};
```

---

## ğŸ Reward ç³»ç»Ÿé›†æˆ

### ç³»ç»Ÿæ¦‚è¿°

Reward ç³»ç»Ÿæ˜¯ä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·æ¿€åŠ±å’Œç‰¹æƒç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š

1. **ç§¯åˆ†å¥–åŠ±**ï¼šç”¨æˆ·é€šè¿‡å€Ÿè´·æ´»åŠ¨è·å¾—ç§¯åˆ†
2. **æœåŠ¡æ¶ˆè´¹**ï¼šç”¨æˆ·ä½¿ç”¨ç§¯åˆ†è´­ä¹°ç‰¹æƒæœåŠ¡
3. **æœåŠ¡é…ç½®**ï¼šç®¡ç†å‘˜é…ç½®å„ç§æœåŠ¡çš„ä»·æ ¼å’ŒåŠŸèƒ½
4. **ç”¨æˆ·ç­‰çº§**ï¼šåŸºäºç§¯åˆ†å’Œè¡Œä¸ºçš„ç”¨æˆ·ç­‰çº§ç³»ç»Ÿ

### æ ¸å¿ƒåˆçº¦

```typescript
interface RewardContracts {
  rewardManager: string;        // ç§¯åˆ†ç®¡ç†åˆçº¦
  rewardPoints: string;         // ç§¯åˆ†ä»£å¸åˆçº¦
  rewardConsumption: string;    // ç§¯åˆ†æ¶ˆè´¹åˆçº¦
  serviceConfigs: {             // æœåŠ¡é…ç½®åˆçº¦
    featureUnlock: string;      // åŠŸèƒ½è§£é”æœåŠ¡
    governanceAccess: string;   // æ²»ç†è®¿é—®æœåŠ¡
    priorityService: string;    // ä¼˜å…ˆæœåŠ¡
    advancedAnalytics: string;  // é«˜çº§åˆ†ææœåŠ¡
    testnetFeatures: string;    // æµ‹è¯•ç½‘åŠŸèƒ½
  };
}
```

### 1. ç§¯åˆ†ç®¡ç† (RewardManager)

#### è·å–ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯

```typescript
const getUserRewardInfo = async (userAddress: string) => {
  try {
    const rewardManager = new ethers.Contract(
      rewardManagerAddress,
      REWARD_MANAGER_ABI,
      provider
    );

    const [points, level, lastUpdateTime] = await Promise.all([
      rewardManager.getUserPoints(userAddress),
      rewardManager.getUserLevel(userAddress),
      rewardManager.getUserLastUpdateTime(userAddress)
    ]);

    return {
      points: points.toString(),
      level: level.toNumber(),
      lastUpdateTime: lastUpdateTime.toNumber()
    };
  } catch (error) {
    console.error('Failed to get user reward info:', error);
    throw error;
  }
};
```

#### è·å–å¥–åŠ±å‚æ•°

```typescript
const getRewardParameters = async () => {
  try {
    const rewardManager = new ethers.Contract(
      rewardManagerAddress,
      REWARD_MANAGER_ABI,
      provider
    );

    const [
      basePointPerHundredUsd,
      durationPointPerDay,
      earlyRepayBonus,
      basePointPerEth
    ] = await Promise.all([
      rewardManager.basePointPerHundredUsd(),
      rewardManager.durationPointPerDay(),
      rewardManager.earlyRepayBonus(),
      rewardManager.basePointPerEth()
    ]);

    return {
      basePointPerHundredUsd: basePointPerHundredUsd.toString(),
      durationPointPerDay: durationPointPerDay.toString(),
      earlyRepayBonus: earlyRepayBonus.toString(),
      basePointPerEth: basePointPerEth.toString()
    };
  } catch (error) {
    console.error('Failed to get reward parameters:', error);
    throw error;
  }
};
```

#### è®¡ç®—é¢„æœŸç§¯åˆ†

```typescript
const calculateExpectedReward = async (
  userAddress: string,
  operation: 'deposit' | 'borrow' | 'repay',
  amount: string,
  asset: string
) => {
  try {
    const rewardManager = new ethers.Contract(
      rewardManagerAddress,
      REWARD_MANAGER_ABI,
      provider
    );

    // è·å–èµ„äº§ä»·æ ¼
    const priceOracle = new ethers.Contract(
      priceOracleAddress,
      PRICE_ORACLE_ABI,
      provider
    );
    const [price] = await priceOracle.getPrice(asset);
    
    // è®¡ç®—é¢„æœŸç§¯åˆ†
    const expectedPoints = await rewardManager.calculateExpectedReward(
      userAddress,
      operation,
      amount,
      price
    );

    return expectedPoints.toString();
  } catch (error) {
    console.error('Failed to calculate expected reward:', error);
    throw error;
  }
};
```

### 2. ç§¯åˆ†ä»£å¸ (RewardPoints)

#### æŸ¥è¯¢ç§¯åˆ†ä½™é¢

```typescript
const getPointsBalance = async (userAddress: string) => {
  try {
    const rewardPoints = new ethers.Contract(
      rewardPointsAddress,
      REWARD_POINTS_ABI,
      provider
    );

    const balance = await rewardPoints.balanceOf(userAddress);
    return balance.toString();
  } catch (error) {
    console.error('Failed to get points balance:', error);
    throw error;
  }
};
```

#### æŸ¥è¯¢ç§¯åˆ†å†å²

```typescript
const getPointsHistory = async (userAddress: string) => {
  try {
    const rewardPoints = new ethers.Contract(
      rewardPointsAddress,
      REWARD_POINTS_ABI,
      provider
    );

    // è·å–ç§¯åˆ†é“¸é€ äº‹ä»¶
    const mintFilter = rewardPoints.filters.Transfer(
      ethers.constants.AddressZero,
      userAddress
    );
    const mintEvents = await rewardPoints.queryFilter(mintFilter);

    // è·å–ç§¯åˆ†æ¶ˆè´¹äº‹ä»¶
    const burnFilter = rewardPoints.filters.Transfer(
      userAddress,
      ethers.constants.AddressZero
    );
    const burnEvents = await rewardPoints.queryFilter(burnFilter);

    return {
      mints: mintEvents.map(event => ({
        amount: event.args?.value.toString(),
        timestamp: event.blockNumber
      })),
      burns: burnEvents.map(event => ({
        amount: event.args?.value.toString(),
        timestamp: event.blockNumber
      }))
    };
  } catch (error) {
    console.error('Failed to get points history:', error);
    throw error;
  }
};
```

### 3. æœåŠ¡é…ç½®ç®¡ç†

#### è·å–æœåŠ¡é…ç½®

```typescript
const getServiceConfig = async (serviceType: number, level: number) => {
  try {
    // æ ¹æ®æœåŠ¡ç±»å‹è·å–å¯¹åº”çš„é…ç½®åˆçº¦
    const serviceConfigAddress = getServiceConfigAddress(serviceType);
    const serviceConfig = new ethers.Contract(
      serviceConfigAddress,
      SERVICE_CONFIG_ABI,
      provider
    );

    const config = await serviceConfig.getConfig(level);
    
    return {
      price: config.price.toString(),
      duration: config.duration.toString(),
      isActive: config.isActive,
      level: config.level.toNumber(),
      description: config.description
    };
  } catch (error) {
    console.error('Failed to get service config:', error);
    throw error;
  }
};

const getServiceConfigAddress = (serviceType: number) => {
  const serviceConfigs = {
    0: '0x...', // FeatureUnlock
    1: '0x...', // GovernanceAccess
    2: '0x...', // PriorityService
    3: '0x...', // AdvancedAnalytics
    4: '0x...'  // TestnetFeatures
  };
  return serviceConfigs[serviceType];
};
```

#### è·å–æ‰€æœ‰æœåŠ¡é…ç½®

```typescript
const getAllServiceConfigs = async () => {
  try {
    const serviceTypes = [0, 1, 2, 3, 4]; // æ‰€æœ‰æœåŠ¡ç±»å‹
    const levels = [0, 1, 2, 3]; // æ‰€æœ‰ç­‰çº§

    const allConfigs = {};

    for (const serviceType of serviceTypes) {
      allConfigs[serviceType] = {};
      
      for (const level of levels) {
        const config = await getServiceConfig(serviceType, level);
        allConfigs[serviceType][level] = config;
      }
    }

    return allConfigs;
  } catch (error) {
    console.error('Failed to get all service configs:', error);
    throw error;
  }
};
```

### 4. ç§¯åˆ†æ¶ˆè´¹ (RewardConsumption)

#### æ¶ˆè´¹æœåŠ¡

```typescript
const consumeService = async (
  serviceType: number,
  level: number,
  points: string
) => {
  try {
    const rewardConsumption = new ethers.Contract(
      rewardConsumptionAddress,
      REWARD_CONSUMPTION_ABI,
      signer
    );

    // æ£€æŸ¥ç§¯åˆ†ä½™é¢
    const balance = await getPointsBalance(userAddress);
    if (ethers.BigNumber.from(balance).lt(points)) {
      throw new Error('Insufficient points');
    }

    // æ‰§è¡Œæ¶ˆè´¹
    const tx = await rewardConsumption.consumeService(serviceType, level, points);
    const receipt = await tx.wait();

    // ç›‘å¬æ¶ˆè´¹äº‹ä»¶
    const consumeEvent = receipt.events?.find(e => e.event === 'ServiceConsumed');
    console.log('Service consumed:', consumeEvent?.args);

    return receipt;
  } catch (error) {
    console.error('Failed to consume service:', error);
    throw error;
  }
};
```

#### æŸ¥è¯¢ç”¨æˆ·ç‰¹æƒ

```typescript
const getUserPrivileges = async (userAddress: string) => {
  try {
    const rewardConsumption = new ethers.Contract(
      rewardConsumptionAddress,
      REWARD_CONSUMPTION_ABI,
      provider
    );

    const serviceTypes = [0, 1, 2, 3, 4];
    const privileges = {};

    for (const serviceType of serviceTypes) {
      const privilege = await rewardConsumption.getUserPrivilege(
        userAddress,
        serviceType
      );
      
      privileges[serviceType] = {
        level: privilege.level.toNumber(),
        isActive: privilege.isActive,
        expirationTime: privilege.expirationTime.toNumber()
      };
    }

    return privileges;
  } catch (error) {
    console.error('Failed to get user privileges:', error);
    throw error;
  }
};
```

#### æŸ¥è¯¢æ¶ˆè´¹è®°å½•

```typescript
const getConsumptionRecords = async (userAddress: string) => {
  try {
    const rewardConsumption = new ethers.Contract(
      rewardConsumptionAddress,
      REWARD_CONSUMPTION_ABI,
      provider
    );

    const records = await rewardConsumption.getUserConsumptions(userAddress);
    
    return records.map(record => ({
      points: record.points.toString(),
      timestamp: record.timestamp.toNumber(),
      serviceType: record.serviceType.toNumber(),
      serviceLevel: record.serviceLevel.toNumber(),
      isActive: record.isActive,
      expirationTime: record.expirationTime.toNumber()
    }));
  } catch (error) {
    console.error('Failed to get consumption records:', error);
    throw error;
  }
};
```

### 5. æœåŠ¡ç±»å‹å’Œç­‰çº§

```typescript
enum ServiceType {
  FeatureUnlock = 0,      // åŠŸèƒ½è§£é”æœåŠ¡
  GovernanceAccess = 1,   // æ²»ç†è®¿é—®æœåŠ¡
  PriorityService = 2,    // ä¼˜å…ˆæœåŠ¡
  AdvancedAnalytics = 3,  // é«˜çº§åˆ†ææœåŠ¡
  TestnetFeatures = 4     // æµ‹è¯•ç½‘åŠŸèƒ½
}

enum ServiceLevel {
  Basic = 0,      // åŸºç¡€ç­‰çº§
  Standard = 1,   // æ ‡å‡†ç­‰çº§
  Premium = 2,    // é«˜çº§ç­‰çº§
  VIP = 3         // VIPç­‰çº§
}

const getServiceTypeName = (serviceType: number) => {
  const names = {
    0: 'Feature Unlock',
    1: 'Governance Access',
    2: 'Priority Service',
    3: 'Advanced Analytics',
    4: 'Testnet Features'
  };
  return names[serviceType] || 'Unknown';
};

const getServiceLevelName = (level: number) => {
  const names = {
    0: 'Basic',
    1: 'Standard',
    2: 'Premium',
    3: 'VIP'
  };
  return names[level] || 'Unknown';
};
```

### 6. ç”¨æˆ·æ“ä½œæµç¨‹

#### æŸ¥çœ‹ç§¯åˆ†å’Œç‰¹æƒ

```typescript
const getUserRewardDashboard = async (userAddress: string) => {
  try {
    const [rewardInfo, pointsBalance, privileges, consumptionRecords] = await Promise.all([
      getUserRewardInfo(userAddress),
      getPointsBalance(userAddress),
      getUserPrivileges(userAddress),
      getConsumptionRecords(userAddress)
    ]);

    return {
      rewardInfo,
      pointsBalance,
      privileges,
      consumptionRecords,
      // è®¡ç®—å¯ç”¨æœåŠ¡
      availableServices: calculateAvailableServices(privileges, pointsBalance)
    };
  } catch (error) {
    console.error('Failed to get reward dashboard:', error);
    throw error;
  }
};

const calculateAvailableServices = (privileges: any, pointsBalance: string) => {
  const availableServices = [];
  
  // éå†æ‰€æœ‰æœåŠ¡ç±»å‹å’Œç­‰çº§
  for (let serviceType = 0; serviceType < 5; serviceType++) {
    for (let level = 0; level < 4; level++) {
      const config = await getServiceConfig(serviceType, level);
      
      if (config.isActive && ethers.BigNumber.from(pointsBalance).gte(config.price)) {
        availableServices.push({
          serviceType,
          level,
          serviceName: getServiceTypeName(serviceType),
          levelName: getServiceLevelName(level),
          price: config.price,
          description: config.description
        });
      }
    }
  }
  
  return availableServices;
};
```

#### è´­ä¹°æœåŠ¡

```typescript
const purchaseService = async (
  serviceType: number,
  level: number
) => {
  try {
    // 1. è·å–æœåŠ¡é…ç½®
    const config = await getServiceConfig(serviceType, level);
    
    if (!config.isActive) {
      throw new Error('Service is not active');
    }

    // 2. æ£€æŸ¥ç§¯åˆ†ä½™é¢
    const balance = await getPointsBalance(userAddress);
    if (ethers.BigNumber.from(balance).lt(config.price)) {
      throw new Error('Insufficient points');
    }

    // 3. æ¶ˆè´¹æœåŠ¡
    const receipt = await consumeService(serviceType, level, config.price);

    // 4. æ›´æ–°ç”¨æˆ·ç•Œé¢
    await updateUserInterface();

    return {
      success: true,
      receipt,
      serviceType,
      level,
      pointsSpent: config.price,
      duration: config.duration
    };
  } catch (error) {
    console.error('Failed to purchase service:', error);
    throw error;
  }
};
```

### 7. äº‹ä»¶ç›‘å¬

```typescript
const setupRewardEventListeners = () => {
  // ç›‘å¬ç§¯åˆ†å¥–åŠ±äº‹ä»¶
  rewardManager.on('RewardEarned', (user, points, reason, timestamp) => {
    console.log('Reward earned:', {
      user,
      points: points.toString(),
      reason,
      timestamp: timestamp.toString()
    });
  });

  // ç›‘å¬ç”¨æˆ·ç­‰çº§æ›´æ–°äº‹ä»¶
  rewardManager.on('UserLevelUpdated', (actionKey, user, oldLevel, newLevel, updatedBy, timestamp) => {
    console.log('User level updated:', {
      user,
      oldLevel: oldLevel.toNumber(),
      newLevel: newLevel.toNumber(),
      updatedBy,
      timestamp: timestamp.toString()
    });
  });

  // ç›‘å¬æœåŠ¡æ¶ˆè´¹äº‹ä»¶
  rewardConsumption.on('ServiceConsumed', (user, serviceType, level, points, timestamp) => {
    console.log('Service consumed:', {
      user,
      serviceType: serviceType.toNumber(),
      level: level.toNumber(),
      points: points.toString(),
      timestamp: timestamp.toString()
    });
  });

  // ç›‘å¬æœåŠ¡é…ç½®æ›´æ–°äº‹ä»¶
  rewardConsumption.on('ServiceConfigUpdated', (serviceType, level, price, duration) => {
    console.log('Service config updated:', {
      serviceType: serviceType.toNumber(),
      level: level.toNumber(),
      price: price.toString(),
      duration: duration.toString()
    });
  });

  // ç›‘å¬ç”¨æˆ·ç‰¹æƒæ›´æ–°äº‹ä»¶
  rewardConsumption.on('UserPrivilegeUpdated', (user, serviceType, level, granted) => {
    console.log('User privilege updated:', {
      user,
      serviceType: serviceType.toNumber(),
      level: level.toNumber(),
      granted
    });
  });
};
```

### 8. é”™è¯¯å¤„ç†

```typescript
enum RewardErrors {
  INSUFFICIENT_POINTS = 'InsufficientPoints',
  SERVICE_NOT_ACTIVE = 'ServiceNotActive',
  INVALID_SERVICE_TYPE = 'InvalidServiceType',
  INVALID_SERVICE_LEVEL = 'InvalidServiceLevel',
  PRIVILEGE_EXPIRED = 'PrivilegeExpired',
  COOLDOWN_NOT_MET = 'CooldownNotMet'
}

const handleRewardError = (error: any) => {
  if (error.code === 'CALL_EXCEPTION') {
    const errorData = error.data;
    const decodedError = decodeRevertError(errorData);
    
    switch (decodedError.errorName) {
      case RewardErrors.INSUFFICIENT_POINTS:
        return 'Insufficient points for this service';
      case RewardErrors.SERVICE_NOT_ACTIVE:
        return 'Service is not currently active';
      case RewardErrors.INVALID_SERVICE_TYPE:
        return 'Invalid service type';
      case RewardErrors.INVALID_SERVICE_LEVEL:
        return 'Invalid service level';
      case RewardErrors.PRIVILEGE_EXPIRED:
        return 'Service privilege has expired';
      case RewardErrors.COOLDOWN_NOT_MET:
        return 'Service cooldown period not met';
      default:
        return 'Reward operation failed';
    }
  }
  
  return error.message || 'Unknown reward error';
};
```

---

## ğŸ‘¤ ç”¨æˆ·æ“ä½œæµç¨‹

### 1. å­˜å…¥æŠµæŠ¼ç‰©

```typescript
const depositCollateral = async (assetAddress: string, amount: string) => {
  try {
    // 1. éªŒè¯èµ„äº§æ˜¯å¦åœ¨ç™½åå•ä¸­
    const isAllowed = await assetWhitelist.isAssetAllowed(assetAddress);
    if (!isAllowed) {
      throw new Error('Asset not allowed');
    }

    // 2. è·å–ç”¨æˆ·æˆæƒ
    const tokenContract = new ethers.Contract(assetAddress, ERC20_ABI, signer);
    const allowance = await tokenContract.allowance(userAddress, vaultAddress);
    
    if (allowance.lt(amount)) {
      const approveTx = await tokenContract.approve(vaultAddress, amount);
      await approveTx.wait();
    }

    // 3. æ‰§è¡Œå­˜å…¥æ“ä½œ
    const vaultContract = new ethers.Contract(vaultAddress, VAULT_ABI, signer);
    const tx = await vaultContract.deposit(assetAddress, amount);
    const receipt = await tx.wait();

    // 4. ç›‘å¬äº‹ä»¶
    const depositEvent = receipt.events?.find(e => e.event === 'Deposit');
    console.log('Deposit successful:', depositEvent?.args);

    return receipt;
  } catch (error) {
    console.error('Deposit failed:', error);
    throw error;
  }
};
```

### 2. å€Ÿæ¬¾

```typescript
const borrowAsset = async (assetAddress: string, amount: string) => {
  try {
    // 1. éªŒè¯èµ„äº§æ˜¯å¦åœ¨ç™½åå•ä¸­
    const isAllowed = await assetWhitelist.isAssetAllowed(assetAddress);
    if (!isAllowed) {
      throw new Error('Asset not allowed');
    }

    // 2. æ£€æŸ¥å¥åº·å› å­
    const healthFactor = await calculateHealthFactor(userAddress);
    if (healthFactor < minHealthFactor) {
      throw new Error('Health factor too low');
    }

    // 3. æ‰§è¡Œå€Ÿæ¬¾æ“ä½œ
    const vaultContract = new ethers.Contract(vaultAddress, VAULT_ABI, signer);
    const tx = await vaultContract.borrow(assetAddress, amount);
    const receipt = await tx.wait();

    // 4. ç›‘å¬äº‹ä»¶
    const borrowEvent = receipt.events?.find(e => e.event === 'Borrow');
    console.log('Borrow successful:', borrowEvent?.args);

    return receipt;
  } catch (error) {
    console.error('Borrow failed:', error);
    throw error;
  }
};
```

### 5. ä¿è¯é‡‘æŸ¥è¯¢

```typescript
// æŸ¥è¯¢ç”¨æˆ·ä¿è¯é‡‘ä¿¡æ¯
const getGuaranteeInfo = async (userAddress: string, assetAddress: string) => {
  try {
    const guaranteeManager = new ethers.Contract(
      guaranteeManagerAddress,
      GUARANTEE_MANAGER_ABI,
      provider
    );

    const [lockedAmount, totalByAsset, userAssets] = await Promise.all([
      guaranteeManager.getLockedGuarantee(userAddress, assetAddress),
      guaranteeManager.getTotalGuaranteeByAsset(assetAddress),
      guaranteeManager.getUserGuaranteeAssets(userAddress)
    ]);

    return {
      lockedAmount: lockedAmount.toString(),
      totalByAsset: totalByAsset.toString(),
      userAssets: userAssets
    };
  } catch (error) {
    console.error('Failed to get guarantee info:', error);
    throw error;
  }
};

// æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰ä¿è¯é‡‘
const getUserAllGuarantees = async (userAddress: string) => {
  try {
    const guaranteeManager = new ethers.Contract(
      guaranteeManagerAddress,
      GUARANTEE_MANAGER_ABI,
      provider
    );

    const userAssets = await guaranteeManager.getUserGuaranteeAssets(userAddress);
    const guarantees = await Promise.all(
      userAssets.map(async (asset: string) => {
        const amount = await guaranteeManager.getLockedGuarantee(userAddress, asset);
        return {
          asset,
          amount: amount.toString()
        };
      })
    );

    return guarantees;
  } catch (error) {
    console.error('Failed to get user guarantees:', error);
    throw error;
  }
};
```

### 3. è¿˜æ¬¾

```typescript
const repayAsset = async (assetAddress: string, amount: string) => {
  try {
    // 1. éªŒè¯èµ„äº§æ˜¯å¦åœ¨ç™½åå•ä¸­
    const isAllowed = await assetWhitelist.isAssetAllowed(assetAddress);
    if (!isAllowed) {
      throw new Error('Asset not allowed');
    }

    // 2. è·å–ç”¨æˆ·æˆæƒ
    const tokenContract = new ethers.Contract(assetAddress, ERC20_ABI, signer);
    const allowance = await tokenContract.allowance(userAddress, vaultAddress);
    
    if (allowance.lt(amount)) {
      const approveTx = await tokenContract.approve(vaultAddress, amount);
      await approveTx.wait();
    }

    // 3. æ‰§è¡Œè¿˜æ¬¾æ“ä½œ
    const vaultContract = new ethers.Contract(vaultAddress, VAULT_ABI, signer);
    const tx = await vaultContract.repay(assetAddress, amount);
    const receipt = await tx.wait();

    // 4. ç›‘å¬äº‹ä»¶
    const repayEvent = receipt.events?.find(e => e.event === 'Repay');
    console.log('Repay successful:', repayEvent?.args);

    return receipt;
  } catch (error) {
    console.error('Repay failed:', error);
    throw error;
  }
};
```

### 4. å¤åˆæ“ä½œ

```typescript
// å­˜å…¥å¹¶å€Ÿæ¬¾
const depositAndBorrow = async (
  collateralAsset: string,
  collateralAmount: string,
  borrowAsset: string,
  borrowAmount: string
) => {
  try {
    // 1. éªŒè¯ä¸¤ä¸ªèµ„äº§éƒ½åœ¨ç™½åå•ä¸­
    const [collateralAllowed, borrowAllowed] = await Promise.all([
      assetWhitelist.isAssetAllowed(collateralAsset),
      assetWhitelist.isAssetAllowed(borrowAsset)
    ]);

    if (!collateralAllowed || !borrowAllowed) {
      throw new Error('Asset not allowed');
    }

    // 2. è·å–æŠµæŠ¼èµ„äº§æˆæƒ
    const collateralToken = new ethers.Contract(collateralAsset, ERC20_ABI, signer);
    const allowance = await collateralToken.allowance(userAddress, vaultAddress);
    
    if (allowance.lt(collateralAmount)) {
      const approveTx = await collateralToken.approve(vaultAddress, collateralAmount);
      await approveTx.wait();
    }

    // 3. æ‰§è¡Œå¤åˆæ“ä½œ
    const vaultContract = new ethers.Contract(vaultAddress, VAULT_ABI, signer);
    const tx = await vaultContract.depositAndBorrow(
      collateralAsset,
      collateralAmount,
      borrowAsset,
      borrowAmount
    );
    const receipt = await tx.wait();

    return receipt;
  } catch (error) {
    console.error('Deposit and borrow failed:', error);
    throw error;
  }
};
```

---

## âš ï¸ é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯ç±»å‹

```typescript
enum VaultErrors {
  AMOUNT_IS_ZERO = 'AmountIsZero',
  INSUFFICIENT_COLLATERAL = 'InsufficientCollateral',
  HEALTH_FACTOR_TOO_LOW = 'HealthFactorTooLow',
  ASSET_NOT_ALLOWED = 'AssetNotAllowed',
  PRICE_ORACLE_ASSET_NOT_SUPPORTED = 'PriceOracle__AssetNotSupported',
  PRICE_ORACLE_STALE_PRICE = 'PriceOracle__StalePrice',
  PRICE_ORACLE_INVALID_PRICE = 'PriceOracle__InvalidPrice',
  EXTERNAL_MODULE_REVERTED = 'ExternalModuleRevertedRaw'
}
```

### é”™è¯¯å¤„ç†å‡½æ•°

```typescript
const handleVaultError = (error: any) => {
  if (error.code === 'CALL_EXCEPTION') {
    // è§£æ revert é”™è¯¯
    const errorData = error.data;
    const decodedError = decodeRevertError(errorData);
    
    switch (decodedError.errorName) {
      case VaultErrors.AMOUNT_IS_ZERO:
        return 'Amount cannot be zero';
      case VaultErrors.INSUFFICIENT_COLLATERAL:
        return 'Insufficient collateral';
      case VaultErrors.HEALTH_FACTOR_TOO_LOW:
        return 'Health factor too low';
      case VaultErrors.ASSET_NOT_ALLOWED:
        return 'Asset not allowed';
      case VaultErrors.PRICE_ORACLE_ASSET_NOT_SUPPORTED:
        return 'Asset not supported by price oracle';
      case VaultErrors.PRICE_ORACLE_STALE_PRICE:
        return 'Price data is stale';
      case VaultErrors.PRICE_ORACLE_INVALID_PRICE:
        return 'Invalid price data';
      default:
        return 'Transaction failed';
    }
  }
  
  return error.message || 'Unknown error';
};

const decodeRevertError = (errorData: string) => {
  // å®ç°é”™è¯¯è§£ç é€»è¾‘
  // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„é”™è¯¯æ ¼å¼æ¥å®ç°
  return { errorName: 'Unknown', errorArgs: [] };
};
```

---

## ğŸ”’ å®‰å…¨æœ€ä½³å®è·µ

### 1. è¾“å…¥éªŒè¯

```typescript
const validateInputs = (assetAddress: string, amount: string) => {
  // éªŒè¯åœ°å€æ ¼å¼
  if (!ethers.utils.isAddress(assetAddress)) {
    throw new Error('Invalid asset address');
  }

  // éªŒè¯é‡‘é¢æ ¼å¼
  if (!amount || amount === '0') {
    throw new Error('Amount must be greater than 0');
  }

  // éªŒè¯é‡‘é¢ç²¾åº¦
  const amountBN = ethers.BigNumber.from(amount);
  if (amountBN.isZero()) {
    throw new Error('Amount cannot be zero');
  }
};
```

### 2. ä»·æ ¼éªŒè¯

```typescript
const validatePrice = async (assetAddress: string) => {
  const priceData = await getAssetPrice(assetAddress);
  
  if (!priceData || !priceData.isValid) {
    throw new Error('Invalid or stale price data');
  }
  
  // æ£€æŸ¥ä»·æ ¼æ˜¯å¦åœ¨åˆç†èŒƒå›´å†…
  const price = parseFloat(priceData.price) / Math.pow(10, priceData.decimals);
  if (price <= 0 || price > 1000000) { // å‡è®¾æœ€å¤§ä»·æ ¼ä¸º 1,000,000
    throw new Error('Price out of reasonable range');
  }
  
  return priceData;
};
```

### 3. å¥åº·å› å­ç›‘æ§

```typescript
const monitorHealthFactor = async (userAddress: string) => {
  const healthFactor = await calculateHealthFactor(userAddress);
  const minHealthFactor = await vaultContract.minHealthFactor();
  
  if (healthFactor < minHealthFactor) {
    console.warn('Health factor below minimum:', healthFactor.toString());
    return false;
  }
  
  return true;
};
```

### 4. äº¤æ˜“ç¡®è®¤

```typescript
const waitForTransaction = async (tx: any, confirmations: number = 1) => {
  try {
    const receipt = await tx.wait(confirmations);
    
    // éªŒè¯äº¤æ˜“çŠ¶æ€
    if (receipt.status === 0) {
      throw new Error('Transaction failed');
    }
    
    return receipt;
  } catch (error) {
    console.error('Transaction failed:', error);
    throw error;
  }
};
```

---

## ğŸ§ª æµ‹è¯•æŒ‡å—

### 1. å•å…ƒæµ‹è¯•

```typescript
describe('Vault Integration', () => {
  it('should deposit collateral successfully', async () => {
    const assetAddress = '0x...'; // æµ‹è¯•èµ„äº§åœ°å€
    const amount = ethers.utils.parseEther('100');
    
    const tx = await vaultContract.deposit(assetAddress, amount);
    const receipt = await tx.wait();
    
    expect(receipt.status).to.equal(1);
    
    const depositEvent = receipt.events?.find(e => e.event === 'Deposit');
    expect(depositEvent).to.not.be.undefined;
    expect(depositEvent.args.user).to.equal(userAddress);
    expect(depositEvent.args.asset).to.equal(assetAddress);
    expect(depositEvent.args.amount).to.equal(amount);
  });
});
```

### 2. é›†æˆæµ‹è¯•

```typescript
describe('Multi-Asset Operations', () => {
  it('should handle multiple assets correctly', async () => {
    const assets = ['0x...', '0x...', '0x...']; // æµ‹è¯•èµ„äº§åˆ—è¡¨
    
    for (const asset of assets) {
      // éªŒè¯èµ„äº§æ˜¯å¦æ”¯æŒ
      const isSupported = await priceOracle.isPriceValid(asset);
      expect(isSupported).to.be.true;
      
      // æµ‹è¯•å­˜å…¥æ“ä½œ
      const amount = ethers.utils.parseEther('10');
      const tx = await vaultContract.deposit(asset, amount);
      await tx.wait();
      
      // éªŒè¯ä½™é¢
      const balance = await collateralManager.getCollateral(userAddress, asset);
      expect(balance).to.equal(amount);
    }
  });
});
```

### 3. å‹åŠ›æµ‹è¯•

```typescript
describe('Price Oracle Stress Test', () => {
  it('should handle price updates correctly', async () => {
    const assets = await priceOracle.getSupportedAssets();
    
    // æ‰¹é‡è·å–ä»·æ ¼
    const prices = await priceOracle.getPrices(assets);
    
    expect(prices.prices.length).to.equal(assets.length);
    expect(prices.timestamps.length).to.equal(assets.length);
    
    // éªŒè¯ä»·æ ¼æœ‰æ•ˆæ€§
    for (let i = 0; i < assets.length; i++) {
      const isValid = await priceOracle.isPriceValid(assets[i]);
      expect(isValid).to.be.true;
    }
  });
});
```

---

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### 1. äº‹ä»¶ç›‘å¬

```typescript
const setupEventListeners = () => {
  // ç›‘å¬ä»·æ ¼æ›´æ–°äº‹ä»¶
  priceOracle.on('PriceUpdated', (asset, price, timestamp) => {
    console.log('Price updated:', {
      asset,
      price: price.toString(),
      timestamp: timestamp.toString()
    });
  });
  
  // ç›‘å¬ç”¨æˆ·æ“ä½œäº‹ä»¶
  vaultContract.on('Deposit', (user, asset, amount) => {
    console.log('User deposited:', {
      user,
      asset,
      amount: amount.toString()
    });
  });
  
  vaultContract.on('Borrow', (user, asset, amount) => {
    console.log('User borrowed:', {
      user,
      asset,
      amount: amount.toString()
    });
  });
  
  // ç›‘å¬ä¿è¯é‡‘ç›¸å…³äº‹ä»¶
  guaranteeManager.on('GuaranteeLocked', (user, asset, amount, timestamp) => {
    console.log('Guarantee locked:', {
      user,
      asset,
      amount: amount.toString(),
      timestamp: timestamp.toString()
    });
  });
  
  guaranteeManager.on('GuaranteeReleased', (user, asset, amount, timestamp) => {
    console.log('Guarantee released:', {
      user,
      asset,
      amount: amount.toString(),
      timestamp: timestamp.toString()
    });
  });
  
  guaranteeManager.on('GuaranteeForfeited', (user, asset, amount, feeReceiver, timestamp) => {
    console.log('Guarantee forfeited:', {
      user,
      asset,
      amount: amount.toString(),
      feeReceiver,
      timestamp: timestamp.toString()
    });
  });
  
  // ç›‘å¬æ ‡å‡†åŒ–åŠ¨ä½œäº‹ä»¶
  vaultContract.on('ActionExecuted', (actionKey, actionString, caller, timestamp) => {
    console.log('Action executed:', {
      actionKey,
      actionString,
      caller,
      timestamp: timestamp.toString()
    });
  });
};
```

### 2. æ€§èƒ½ç›‘æ§

```typescript
const monitorPerformance = async () => {
  const startTime = Date.now();
  
  try {
    await performOperation();
    const endTime = Date.now();
    console.log(`Operation completed in ${endTime - startTime}ms`);
  } catch (error) {
    console.error('Operation failed:', error);
  }
};
```

---

## ğŸ”„ æ›´æ–°æ—¥å¿—

### v3.0.0 (2025-01-27) - æ¶æ„é‡æ„ç‰ˆæœ¬
- âœ… **é‡‡ç”¨æ–¹å¼1æ¶æ„**ï¼šç›´æ¥è°ƒç”¨å¤šä¸ªåˆçº¦ï¼Œä¼˜åŒ– Gas è´¹ç”¨
- âœ… **æ¶æ„æ¸…æ™°åŒ–**ï¼šæ¯ä¸ªåˆçº¦èŒè´£æ˜ç¡®ï¼Œä¾¿äºç»´æŠ¤å’Œå‡çº§
- âœ… **çµæ´»æ€§æå‡**ï¼šç”¨æˆ·å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©è°ƒç”¨å“ªäº›åŠŸèƒ½
- âœ… **è°ƒè¯•å‹å¥½**ï¼šé—®é¢˜å®šä½æ›´å®¹æ˜“ï¼Œé”™è¯¯å¤„ç†æ›´ç²¾ç¡®
- âœ… **æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–**ï¼šå®ç°å¹¶è¡ŒæŸ¥è¯¢å’Œç¼“å­˜ç­–ç•¥
- âœ… **æ€§èƒ½ç›‘æ§**ï¼šæ·»åŠ æ€§èƒ½è·Ÿè¸ªå’Œé”™è¯¯å¤„ç†ä¼˜åŒ–
- âœ… **Gas è´¹ç”¨ä¼˜åŒ–**ï¼šå‡å°‘ä¸­é—´å±‚è°ƒç”¨ï¼Œé™ä½ gas æ¶ˆè€—

### v2.2.0 (2025-01-27)
- âœ… é›†æˆå®Œæ•´çš„ Reward ç§¯åˆ†å¥–åŠ±ç³»ç»Ÿ
- âœ… æ·»åŠ ç§¯åˆ†ç®¡ç†ã€æ¶ˆè´¹ã€ç‰¹æƒç®¡ç†åŠŸèƒ½
- âœ… å®ç°æœåŠ¡é…ç½®ç®¡ç†ç³»ç»Ÿ
- âœ… æ”¯æŒ 5 ç§æœåŠ¡ç±»å‹å’Œ 4 ä¸ªç­‰çº§
- âœ… æ·»åŠ ç§¯åˆ†å†å²æŸ¥è¯¢å’Œç”¨æˆ·ç­‰çº§ç³»ç»Ÿ
- âœ… å®ç°æœåŠ¡è´­ä¹°å’Œç‰¹æƒéªŒè¯åŠŸèƒ½
- âœ… æ›´æ–°å‰ç«¯é›†æˆè§„åˆ™ä»¥æ”¯æŒ Reward ç³»ç»Ÿ

### v2.1.0 (2025-01-27)
- âœ… é›†æˆä¿è¯é‡‘ç®¡ç†ç³»ç»Ÿ
- âœ… æ·»åŠ ä¿è¯é‡‘æŸ¥è¯¢æ¥å£
- âœ… å®ç°æ ‡å‡†åŒ–åŠ¨ä½œäº‹ä»¶ç›‘å¬
- âœ… æ”¯æŒä¿è¯é‡‘é”å®šã€é‡Šæ”¾ã€æ²¡æ”¶äº‹ä»¶
- âœ… æ›´æ–°å‰ç«¯é›†æˆè§„åˆ™ä»¥æ”¯æŒä¿è¯é‡‘æ“ä½œ

### v2.0.0 (2025-01-27)
- âœ… æ·»åŠ å¤šèµ„äº§æ”¯æŒ
- âœ… é›†æˆ Coingecko ä»·æ ¼é¢„è¨€æœº
- âœ… æ›´æ–°æ‰€æœ‰åˆçº¦æ¥å£ä»¥æ”¯æŒèµ„äº§å‚æ•°
- âœ… æ·»åŠ èµ„äº§ç™½åå•ç®¡ç†
- âœ… å®ç°å®æ—¶ä»·æ ¼è®¡ç®—
- âœ… æ›´æ–°äº‹ä»¶å®šä¹‰ä»¥æ”¯æŒå¤šèµ„äº§

### v1.0.0 (2024-12-XX)
- âœ… åŸºç¡€å€Ÿè´·åŠŸèƒ½
- âœ… å•èµ„äº§æ”¯æŒ
- âœ… åŸºç¡€å®‰å…¨æœºåˆ¶

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### ğŸš€ Gas è´¹ç”¨ä¼˜åŒ–ç­–ç•¥

#### 1. æ‰¹é‡æ“ä½œä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šå¤šæ¬¡å•ç‹¬è°ƒç”¨
const depositMultipleAssets = async (assets: string[], amounts: string[]) => {
  for (let i = 0; i < assets.length; i++) {
    await vaultCore.deposit(assets[i], amounts[i]);
  }
};

// ä¼˜åŒ–åï¼šæ‰¹é‡è°ƒç”¨
const depositMultipleAssetsOptimized = async (assets: string[], amounts: string[]) => {
  await vaultCore.batchDeposit(assets, amounts);
};
```

#### 2. å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šä¸²è¡ŒæŸ¥è¯¢
const getUserDashboard = async (user: string) => {
  const balance = await rewardConsumption.getUserBalance(user);
  const privilege = await rewardConsumption.getUserPrivilege(user);
  const healthFactor = await vaultView.getHealthFactor(user);
  const totalCollateral = await vaultView.getUserTotalCollateral(user);
  
  return { balance, privilege, healthFactor, totalCollateral };
};

// ä¼˜åŒ–åï¼šå¹¶è¡ŒæŸ¥è¯¢
const getUserDashboardOptimized = async (user: string) => {
  const [balance, privilege, healthFactor, totalCollateral] = await Promise.all([
    rewardConsumption.getUserBalance(user),
    rewardConsumption.getUserPrivilege(user),
    vaultView.getHealthFactor(user),
    vaultView.getUserTotalCollateral(user)
  ]);
  
  return { balance, privilege, healthFactor, totalCollateral };
};
```

#### 3. ç¼“å­˜ç­–ç•¥

```typescript
class CacheManager {
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();

  set(key: string, data: any, ttl: number = 60000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  get(key: string) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }

  clear() {
    this.cache.clear();
  }
}

// ä½¿ç”¨ç¼“å­˜ä¼˜åŒ–ä»·æ ¼æŸ¥è¯¢
const priceCache = new CacheManager();

const getAssetPriceWithCache = async (asset: string) => {
  const cacheKey = `price_${asset}`;
  const cached = priceCache.get(cacheKey);
  
  if (cached) {
    return cached;
  }
  
  const price = await priceOracle.getPrice(asset);
  priceCache.set(cacheKey, price, 300000); // 5åˆ†é’Ÿç¼“å­˜
  
  return price;
};
```

### ğŸ“Š æ€§èƒ½ç›‘æ§

```typescript
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  trackOperation(operation: string, duration: number) {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    
    this.metrics.get(operation)!.push(duration);
    
    // åªä¿ç•™æœ€è¿‘100æ¬¡è®°å½•
    if (this.metrics.get(operation)!.length > 100) {
      this.metrics.get(operation)!.shift();
    }
  }

  getAverageDuration(operation: string): number {
    const durations = this.metrics.get(operation) || [];
    if (durations.length === 0) return 0;
    
    return durations.reduce((sum, duration) => sum + duration, 0) / durations.length;
  }

  getSlowestOperations(): Array<{ operation: string; avgDuration: number }> {
    const results = [];
    
    for (const [operation, durations] of this.metrics.entries()) {
      const avgDuration = this.getAverageDuration(operation);
      results.push({ operation, avgDuration });
    }
    
    return results.sort((a, b) => b.avgDuration - a.avgDuration);
  }
}

// ä½¿ç”¨æ€§èƒ½ç›‘æ§
const performanceMonitor = new PerformanceMonitor();

const trackOperation = async <T>(operation: string, fn: () => Promise<T>): Promise<T> => {
  const startTime = Date.now();
  
  try {
    const result = await fn();
    const duration = Date.now() - startTime;
    performanceMonitor.trackOperation(operation, duration);
    return result;
  } catch (error) {
    const duration = Date.now() - startTime;
    performanceMonitor.trackOperation(`${operation}_error`, duration);
    throw error;
  }
};
```

### ğŸ”§ é”™è¯¯å¤„ç†ä¼˜åŒ–

```typescript
class ErrorHandler {
  private static instance: ErrorHandler;
  private errorCounts = new Map<string, number>();

  static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }

  handleError(error: any, context: string) {
    const errorKey = `${context}_${error.code || 'unknown'}`;
    const count = this.errorCounts.get(errorKey) || 0;
    this.errorCounts.set(errorKey, count + 1);

    // è®°å½•é”™è¯¯
    console.error(`Error in ${context}:`, error);
    
    // å¦‚æœé”™è¯¯é¢‘ç‡è¿‡é«˜ï¼Œæš‚åœç›¸å…³æ“ä½œ
    if (count > 10) {
      console.warn(`High error frequency in ${context}, consider pausing operations`);
    }

    return this.getUserFriendlyMessage(error);
  }

  private getUserFriendlyMessage(error: any): string {
    if (error.code === 'CALL_EXCEPTION') {
      return 'Transaction failed. Please check your input and try again.';
    }
    
    if (error.code === 'INSUFFICIENT_FUNDS') {
      return 'Insufficient funds for transaction.';
    }
    
    if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
      return 'Transaction may fail. Please check your parameters.';
    }
    
    return 'An unexpected error occurred. Please try again.';
  }
}
```

### ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

#### âœ… æ¨èåšæ³•

1. **ä½¿ç”¨æ‰¹é‡æ“ä½œ**ï¼šä¼˜å…ˆä½¿ç”¨ `batchDeposit`ã€`batchBorrow` ç­‰æ‰¹é‡å‡½æ•°
2. **å¹¶è¡ŒæŸ¥è¯¢**ï¼šä½¿ç”¨ `Promise.all` å¹¶è¡Œæ‰§è¡Œå¤šä¸ªæŸ¥è¯¢
3. **åˆç†ç¼“å­˜**ï¼šå¯¹é¢‘ç¹æŸ¥è¯¢çš„æ•°æ®è¿›è¡Œé€‚å½“ç¼“å­˜
4. **é”™è¯¯é‡è¯•**ï¼šå¯¹ç½‘ç»œé”™è¯¯å®ç°æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶
5. **æ€§èƒ½ç›‘æ§**ï¼šè·Ÿè¸ªå…³é”®æ“ä½œçš„æ‰§è¡Œæ—¶é—´

#### âŒ é¿å…åšæ³•

1. **é¿å…ä¸²è¡Œè°ƒç”¨**ï¼šä¸è¦åœ¨ä¸€ä¸ªå¾ªç¯ä¸­ä¸²è¡Œè°ƒç”¨åˆçº¦å‡½æ•°
2. **é¿å…è¿‡åº¦æŸ¥è¯¢**ï¼šä¸è¦é¢‘ç¹æŸ¥è¯¢ä¸ç»å¸¸å˜åŒ–çš„æ•°æ®
3. **é¿å…å¤§æ•°ç»„**ï¼šæ‰¹é‡æ“ä½œæ—¶é¿å…ä¼ é€’è¿‡å¤§çš„æ•°ç»„
4. **é¿å…å¿½ç•¥é”™è¯¯**ï¼šå§‹ç»ˆå¤„ç†åˆçº¦è°ƒç”¨çš„é”™è¯¯æƒ…å†µ

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·è”ç³»ï¼š
- ğŸ“§ Email: support@example.com
- ğŸ’¬ Discord: #technical-support
- ğŸ“– æ–‡æ¡£: https://docs.example.com

---

*æœ¬æ–‡æ¡£å°†éšç€å¹³å°åŠŸèƒ½çš„æ›´æ–°è€ŒæŒç»­æ›´æ–°ã€‚è¯·å®šæœŸæ£€æŸ¥æœ€æ–°ç‰ˆæœ¬ã€‚* 