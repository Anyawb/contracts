/**
 * ModuleKeys TypeScript ç”Ÿæˆå™¨
 * ModuleKeys TypeScript Generator
 * 
 * ä» ModuleKeys.sol åˆçº¦è‡ªåŠ¨ç”Ÿæˆå‰ç«¯çš„ moduleKeys.ts æ–‡ä»¶
 * Automatically generate frontend moduleKeys.ts file from ModuleKeys.sol contract
 */

import * as fs from 'fs';
import * as path from 'path';
import { ethers } from 'ethers';

interface ModuleKeyEntry {
  key: string;
  label: string; // the string inside keccak256("...")
}
type ModuleKeyMapping = Record<string, string>;

/**
 * ç”Ÿæˆ TypeScript æ¨¡å—é”®æ–‡ä»¶
 */
export async function generateModuleKeysTS(): Promise<void> {
  console.log('ğŸš€ å¼€å§‹ç”Ÿæˆ ModuleKeys TypeScript æ–‡ä»¶...');
  
  try {
    // 1) è§£æ Solidity æºç ï¼Œæå– bytes32 constant KEY_* = keccak256("...") å®šä¹‰
    const moduleKeysSolPath = path.join(__dirname, '../../src/constants/ModuleKeys.sol');
    const source = fs.readFileSync(moduleKeysSolPath, 'utf8');
    const regex = /bytes32\s+constant\s+(KEY_[A-Z0-9_]+)\s*=\s*keccak256\("([^"]+)"\)/g;
    const entries: ModuleKeyEntry[] = [];
    let match: RegExpExecArray | null;
    while ((match = regex.exec(source)) !== null) {
      entries.push({ key: match[1], label: match[2] });
    }

    if (entries.length === 0) {
      throw new Error('æœªèƒ½åœ¨ ModuleKeys.sol ä¸­è§£æåˆ°ä»»ä½• KEY_* å®šä¹‰ï¼Œè¯·æ£€æŸ¥æ­£åˆ™æˆ–æºç æ ¼å¼ã€‚');
    }

    // ä¿æŒæºç é¡ºåº
    const keyStrings = entries.map((e) => e.key);

    // ç”Ÿæˆå“ˆå¸Œå€¼æ˜ å°„ï¼ˆä¸ Solidity ä¿æŒä¸€è‡´ï¼škeccak256(label)ï¼‰
    const moduleKeyMapping: ModuleKeyMapping = {};
    for (const { key, label } of entries) {
      moduleKeyMapping[key] = ethers.keccak256(ethers.toUtf8Bytes(label));
    }

    // ç”Ÿæˆ TypeScript æ–‡ä»¶å†…å®¹
    const tsContent = generateTypeScriptContent(moduleKeyMapping, keyStrings);
    
    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    const outputDir = path.join(__dirname, '../../frontend-config');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // å†™å…¥æ–‡ä»¶
    const outputPath = path.join(outputDir, 'moduleKeys.ts');
    fs.writeFileSync(outputPath, tsContent, 'utf8');
    
    console.log(`âœ… ModuleKeys TypeScript æ–‡ä»¶å·²ç”Ÿæˆ: ${outputPath}`);
    console.log(`ğŸ“Š æ€»å…±ç”Ÿæˆäº† ${keyStrings.length} ä¸ªæ¨¡å—é”®`);
    
    // ç”ŸæˆéªŒè¯æ–‡ä»¶
    generateValidationFile(moduleKeyMapping, keyStrings);
    
  } catch (error) {
    console.error('âŒ ç”Ÿæˆ ModuleKeys TypeScript æ–‡ä»¶æ—¶å‡ºé”™:', error);
    throw error;
  }
}

/**
 * ç”Ÿæˆ TypeScript æ–‡ä»¶å†…å®¹
 */
function generateTypeScriptContent(
  moduleKeyMapping: ModuleKeyMapping,
  keyStrings: string[]
): string {
  const header = `/**
 * ModuleKeys - æ¨¡å—é”®å¸¸é‡åº“
 * ModuleKeys - Module Key Constants Library
 * 
 * æ­¤æ–‡ä»¶ç”± scripts/utils/generateModuleKeys.ts è‡ªåŠ¨ç”Ÿæˆ
 * This file is automatically generated by scripts/utils/generateModuleKeys.ts
 * 
 * è¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹ï¼Œå¦‚éœ€æ›´æ–°è¯·è¿è¡Œ: npm run generate:module-keys
 * Do not modify manually, run: npm run generate:module-keys to update
 * 
 * ç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}
 * Generated at: ${new Date().toISOString()}
 */

import { ethers } from 'ethers';

/**
 * æ¨¡å—é”®å¸¸é‡æ˜ å°„
 * Module key constants mapping
 */
export const ModuleKeys = {
`;

  const footer = `};

/**
 * æ¨¡å—é”®å­—ç¬¦ä¸²æ•°ç»„
 * Module key strings array
 */
export const MODULE_KEY_STRINGS = [
${keyStrings.map(key => `  '${key}'`).join(',\n')}
] as const;

/**
 * æ¨¡å—é”®ç±»å‹
 * Module key type
 */
export type ModuleKey = typeof MODULE_KEY_STRINGS[number];

/**
 * éªŒè¯æ¨¡å—é”®æ˜¯å¦æœ‰æ•ˆ
 * Validate if module key is valid
 * @param key æ¨¡å—é”® / Module key
 * @returns æ˜¯å¦æœ‰æ•ˆ / Is valid
 */
export function isValidModuleKey(key: string): key is ModuleKey {
  return MODULE_KEY_STRINGS.includes(key as ModuleKey);
}

/**
 * è·å–æ¨¡å—é”®çš„å“ˆå¸Œå€¼
 * Get hash value of module key
 * @param key æ¨¡å—é”® / Module key
 * @returns å“ˆå¸Œå€¼ / Hash value
 */
export function getModuleKeyHash(key: ModuleKey): string {
  return ModuleKeys[key];
}

/**
 * ä»å“ˆå¸Œå€¼è·å–æ¨¡å—é”®
 * Get module key from hash value
 * @param hash å“ˆå¸Œå€¼ / Hash value
 * @returns æ¨¡å—é”®æˆ– null / Module key or null
 */
export function getModuleKeyFromHash(hash: string): ModuleKey | null {
  for (const [key, value] of Object.entries(ModuleKeys)) {
    if (value === hash) {
      return key as ModuleKey;
    }
  }
  return null;
}

/**
 * è·å–æ‰€æœ‰æ¨¡å—é”®
 * Get all module keys
 * @returns æ‰€æœ‰æ¨¡å—é”®æ•°ç»„ / All module keys array
 */
export function getAllModuleKeys(): ModuleKey[] {
  return [...MODULE_KEY_STRINGS];
}

/**
 * è·å–æ¨¡å—é”®æ€»æ•°
 * Get total number of module keys
 * @returns æ¨¡å—é”®æ€»æ•° / Total number of module keys
 */
export function getModuleKeyCount(): number {
  return MODULE_KEY_STRINGS.length;
}

export default ModuleKeys;
`;

  // ç”Ÿæˆä¸»ä½“å†…å®¹
  const body = Object.entries(moduleKeyMapping)
    .map(([key, hash]) => `  ${key}: '${hash}',`)
    .join('\n\n');

  return header + body + '\n' + footer;
}

/**
 * ç”ŸæˆéªŒè¯æ–‡ä»¶
 */
function generateValidationFile(moduleKeyMapping: ModuleKeyMapping, keyStrings: string[]): void {
  const validationContent = `/**
 * ModuleKeys éªŒè¯æ–‡ä»¶
 * ModuleKeys Validation File
 * 
 * ç”¨äºéªŒè¯ç”Ÿæˆçš„æ¨¡å—é”®ä¸åˆçº¦ä¸­çš„å€¼æ˜¯å¦ä¸€è‡´
 * Used to validate that generated module keys match values in contract
 */

import { ModuleKeys } from './moduleKeys';

// éªŒè¯æ‰€æœ‰æ¨¡å—é”®çš„å“ˆå¸Œå€¼æ˜¯å¦æ­£ç¡®
export function validateModuleKeys(): boolean {
  const expectedHashes = {
${Object.entries(moduleKeyMapping)
    .map(([key, hash]) => `    '${key}': '${hash}'`)
    .join(',\n')}
  };

  for (const [key, expectedHash] of Object.entries(expectedHashes)) {
    const actualHash = ModuleKeys[key as keyof typeof ModuleKeys];
    if (actualHash !== expectedHash) {
      console.error(\`âŒ æ¨¡å—é”® \${key} å“ˆå¸Œå€¼ä¸åŒ¹é…:\`);
      console.error(\`   æœŸæœ›: \${expectedHash}\`);
      console.error(\`   å®é™…: \${actualHash}\`);
      return false;
    }
  }

  console.log('âœ… æ‰€æœ‰æ¨¡å—é”®éªŒè¯é€šè¿‡');
  return true;
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶ï¼Œæ‰§è¡ŒéªŒè¯
if (require.main === module) {
  validateModuleKeys();
}
`;

  const outputDir = path.join(__dirname, '../../frontend-config');
  const validationPath = path.join(outputDir, 'moduleKeysValidation.ts');
  fs.writeFileSync(validationPath, validationContent, 'utf8');
  
  console.log(`âœ… ModuleKeys éªŒè¯æ–‡ä»¶å·²ç”Ÿæˆ: ${validationPath}`);
}

/**
 * ä¸»å‡½æ•°
 */
async function main() {
  await generateModuleKeysTS();
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶ï¼Œæ‰§è¡Œä¸»å‡½æ•°
if (require.main === module) {
  main().catch(console.error);
} 